<!DOCTYPE html>
<html lang="ru">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n-title="channelView.pageTitle">Канал | Youvi</title>
    <script>
        (function() {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            
            var htmlClasses = [];
            if (theme === 'dark') htmlClasses.push('dark-theme');
            else if (theme === 'skeuo') htmlClasses.push('skeuo-theme');
            if (sidebar === 'true') htmlClasses.push('sidebar-collapsed');
            if (htmlClasses.length) document.documentElement.className = htmlClasses.join(' ');
        })();
    </script>
    <link rel="stylesheet" href="youvi/header/youvi-header.css">
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/header/youvi-header.js"></script>
    
    <!-- Video ID System -->
    <script src="youvi/video-id.js"></script>
    
    <!-- i18n System -->
    <script src="youvi/i18n/ru.js"></script>
    <script src="youvi/i18n/en.js"></script>
    <script src="youvi/i18n/uk.js"></script>
    <script src="youvi/i18n/i18n.js"></script>
    
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    <link rel="stylesheet" href="youvi/pagination.css">
    <link rel="stylesheet" href="youvi/channel/youvi_ch_view.css">
    
    <style>

        
        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
        }
        
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1500px;
            }
        }
        
        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1600px;
            }
        }
        
        .main-content {
            flex: 1;
            width: 100%;
        }
        
        .header-content-wrapper,
        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
        }
        
        .lang-switcher {
            margin-left: auto;
        }
        
        .lang-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }
        
        .lang-select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .lang-select option {
            background: #d94b88;
            color: #fff;
        }
    </style>
    
    <!-- Theme System -->
    <link rel="stylesheet" href="youvi/themes/dark-theme.css?v=2">
    <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    <link rel="stylesheet" href="youvi/sticky-video.css">
    <link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">
    
    <!-- Autocomplete Module -->
    <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
    <script src="youvi/autocomplete-data-loader.js"></script>
    <script src="youvi/autocomplete/autocomplete-cache.js"></script>
    <script src="youvi/autocomplete/autocomplete.js"></script>
    <script src="youvi/autocomplete/autocomplete-integration.js"></script>
    
    <!-- Danmaku Counter -->
    <script src="youvi/danmaku-counter.js"></script>
    <link rel="stylesheet" href="youvi/danmaku-counter.css">
</head>
<body>
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
      <a href="youvi_main.html" data-i18n="nav.video">Видео</a>
      <a href="index.html" data-i18n="nav.management">Управление</a>
      <a href="youvi_ch_list.html" class="active" data-i18n="nav.channels">Каналы</a>
      <a href="youvi_playlists_list.html" data-i18n="nav.playlists">Плейлисты</a>
      <a href="forum/forum.html" data-i18n="nav.forums">Forums</a> 
      <a href="download/youvi_download.html" data-i18n="nav.download">Download</a> 
      <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
      <div class="lang-switcher">
        <select id="langSwitcher" class="lang-select">
          <option value="ru">RU</option>
          <option value="en">EN</option>
          <option value="uk">UK</option>
        </select>
      </div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content-wrapper">
            <div class="header-left">
                <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle sidebar" data-i18n-aria="header.toggleSidebar">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </button>
                
                <div class="logo">
                    <a href="youvi_main.html">
                        <img src="images/logo_youvi_ind.png" alt="Youvi logo">
                    </a>
                </div>
            </div>
            
            <div class="header-center">
                <div class="search-area autocomplete-wrapper">
                    <input type="text" id="globalSearch" data-i18n-placeholder="search.placeholder" placeholder="Поиск видео..." class="search-input">
                    <button id="doSearch" class="search-btn" data-i18n="search.button">Найти</button>
                </div>
            </div>
            
            <div class="header-right">
                <div class="user-actions">
                    <div class="settings-container">
                        <a href="#" class="settings-btn">⚙</a>
                        <div class="theme-dropdown">
                            <button class="theme-dropdown-item" data-theme="light" data-i18n="themes.light">Белая</button>
                            <button class="theme-dropdown-item" data-theme="dark" data-i18n="themes.dark">Черная</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation">Навигация</div>
                <a href="youvi_main.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9,22 9,12 15,12 15,22"/>
                    </svg>
                    <span data-i18n="sidebar.home">Главная</span>
                </a>
                <a href="youvi_tags.html" class="sidebar-item nav-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                     <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                  <line x1="7" y1="7" x2="7.01" y2="7"/>
                 </svg>
                    <span data-i18n="sidebar.allTags">Все теги</span>
                </a>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library">Библиотека</div>
                <a href="youvi_history.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.history">История</span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <span data-i18n="sidebar.favorites">Избранное</span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="8" y1="8" x2="16" y2="8"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="16" x2="16" y2="16"/>
                        <circle cx="6" cy="8" r="1"/>
                        <circle cx="6" cy="12" r="1"/>
                        <circle cx="6" cy="16" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.playlists">Плейлисты</span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span data-i18n="sidebar.channels">Каналы</span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
                        <polyline points="17,2 12,7 7,2"/>
                    </svg>
                    <span data-i18n="sidebar.subscriptions">Подписки</span>
                </a>
            </div>
            
            <div class="sidebar-section" id="sortingSection" style="display: none;">
                <div class="sidebar-title" data-i18n="sidebar.sorting">Сортировка</div>
                <a href="#" class="sidebar-item library-item active" id="sortNew">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.sortNew">Новые</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortPopular">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                    </svg>
                    <span data-i18n="sidebar.sortPopular">Популярные</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortOld">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    <span data-i18n="sidebar.sortOld">Старые</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortRandom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="3" ry="3"/>
                        <circle cx="8" cy="8" r="1"/>
                        <circle cx="16" cy="8" r="1"/>
                        <circle cx="8" cy="16" r="1"/>
                        <circle cx="16" cy="16" r="1"/>
                        <circle cx="12" cy="12" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.sortRandom">Случайные</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortAlphabetical">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 16L8 6l4 10"/>
                        <path d="M5 13h6"/>
                        <path d="M14 6h6"/>
                        <path d="M14 12h6"/>
                        <path d="M14 18h6"/>
                    </svg>
                    <span data-i18n="sidebar.sortAlphabetical">По алфавиту</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortDanmaku">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span data-i18n="sidebar.sortDanmaku">По данмаку</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle">Подписки</div>
                <div id="subscribedChannelsContainer"></div>
            </div>
        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
        <!-- Main Content -->
        <main class="main-content">
            <div class="channel-header" id="channelHeader">
                <div class="channel-info">
                    <div class="channel-avatar" id="channelAvatar">?</div>
                    <div class="channel-details">
                        <h1 class="channel-name" id="channelName">Название канала</h1>
                        <div class="channel-stats" id="channelStats">0 видео • 0 views</div>
                    </div>
                </div>
                <div class="channel-controls">
                    <button class="subscribe-btn" id="subscribeBtn" data-i18n="channelView.subscribe">Подписаться</button>
                    <button class="control-btn" id="birthdayBtn" data-i18n-title="channelView.birthday" title="День рождения" data-i18n="channelView.birthdayShort">ДР</button>
                    <button class="control-btn" id="avatarBtn" data-i18n-title="channelView.avatar" title="Аватар" data-i18n="channelView.avatarShort">АВ</button>
                    <button class="control-btn" id="headerBtn" data-i18n-title="channelView.header" title="Шапка" data-i18n="channelView.headerShort">ШП</button>
                    <button class="control-btn" id="bgBtn" data-i18n-title="channelView.background" title="Фон" data-i18n="channelView.backgroundShort">ФН</button>
                </div>
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="home" data-i18n="channelView.tabHome">Главная</button>
                <button class="tab" data-tab="videos" data-i18n="channelView.tabVideos">Видео</button>
                <button class="tab" data-tab="analytics" data-i18n="channelView.tabAnalytics">Аналитика</button>
                <button class="tab" data-tab="feed" data-i18n="channelView.tabFeed">Форумы</button>
                <button class="tab" data-tab="playlists" data-i18n="channelView.tabPlaylists">Плейлисты</button>
                <button class="tab" data-tab="description" data-i18n="channelView.tabDescription">Описание</button>
            </div>

                         <div id="homeTab" class="tab-content active">
                 <div style="display:flex;gap:20px;padding:20px;">
                     <div style="flex:1">
                         <div style="margin-bottom:20px">
                             <h3 style="margin:0 0 15px 0" data-i18n="channelView.pinnedVideo">Закрепленное видео</h3>
                             <div id="pinnedVideo" style="background:#fff;border-radius:8px;padding:15px;border:1px solid #eee;min-height:120px">
                                 <div style="text-align:center;color:#999;padding:40px 20px">
                                     <div style="font-size:16px;margin-bottom:10px" data-i18n="channelView.noPinnedVideo">Нет закрепленного видео</div>
                                     <button id="pinVideoBtn" class="btn" data-i18n="channelView.pinVideo">Закрепить видео</button>
                                 </div>
                             </div>
                         </div>
                         
                         <div style="margin-bottom:20px">
                             <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
                                 <h3 style="margin:0" data-i18n="channelView.recentVideos">Последние видео</h3>
                                 <span id="allVideosBtn" style="color:#d94b88;cursor:pointer;font-size:13px;font-weight:600;text-decoration:none;transition:color 0.2s;" data-i18n="channelView.allVideos">Все видео</span>
                             </div>
                             <div class="videos-grid" id="recentVideosGrid">
                                 <!-- Recent videos will be loaded here -->
                             </div>
                         </div>
                         
                         <div style="margin-bottom:20px">
                             <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
                                 <h3 style="margin:0" data-i18n="channelView.moreVideos">Еще видео</h3>
                             </div>
                             <div class="videos-grid" id="recentVideosGrid2">
                                 <!-- Second row of videos will be loaded here -->
                             </div>
                         </div>
                         
                         <div style="margin-bottom:20px">
                             <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
                                 <h3 style="margin:0" data-i18n="channelView.recentPlaylists">Последние плейлисты</h3>
                                 <span id="allPlaylistsBtn" style="color:#d94b88;cursor:pointer;font-size:13px;font-weight:600;text-decoration:none;transition:color 0.2s;" data-i18n="channelView.allPlaylists">Все плейлисты</span>
                             </div>
                             <div id="recentPlaylistsGrid" class="playlists-grid">
                                 <!-- Recent playlists will be loaded here -->
                             </div>
                         </div>
                     </div>
                     <div style="width:320px;flex-shrink:0">
                         <div id="topVideosBlock" style="background:#fff;border-radius:8px;padding:15px;margin-bottom:15px">
                             <h4 style="margin:0 0 10px 0;font-size:18px;color:#333;font-weight:600" data-i18n="channelView.top5Videos">Топ-5 видео</h4>
                             <div id="topVideosList" style="display:flex;flex-direction:column;gap:8px;">
                                 <!-- Top videos will be loaded here -->
                             </div>
                         </div>
                     </div>
                 </div>
             </div>

                         <div id="videosTab" class="tab-content">
                 <div style="display:flex;gap:20px;padding:20px;">
                     <div style="flex:1">
                         <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:15px;">
                             <h3 style="margin:0" data-i18n="channelView.channelVideos">Видео канала</h3>
                             <div style="display:flex;align-items:center;gap:12px;">
                                 <div class="scale-controls" style="display:flex;align-items:center;gap:6px;margin:0;">
                                     <button id="grid3BtnChan" class="btn" aria-label="3 в ряд" data-i18n-title="channelView.grid3Title" title="3 карточки в ряд" style="padding:4px 6px;">3</button>
                                     <button id="grid4BtnChan" class="btn" aria-label="4 в ряд" data-i18n-title="channelView.grid4Title" title="4 карточки в ряд" style="padding:4px 6px;">4</button>
                                     <button id="grid5BtnChan" class="btn" aria-label="5 в ряд" data-i18n-title="channelView.grid5Title" title="5 карточек в ряд" style="padding:4px 6px;">5</button>
                                     <button id="grid6BtnChan" class="btn active" aria-label="6 в ряд" data-i18n-title="channelView.grid6Title" title="6 карточек в ряд" style="padding:4px 6px;">6</button>
                                 </div>
                                 
                             </div>
                         </div>
                         <div class="videos-grid" id="videosGrid" style="grid-template-columns:repeat(6,1fr)">
                             <!-- Videos will be loaded here -->
                         </div>
                     </div>
                 </div>
             </div>

                         <div id="feedTab" class="tab-content">
                             <!-- Содержимое не нужно, так как вкладка перенаправляет на отдельную страницу -->
                         </div>

                         <div id="analyticsTab" class="tab-content">
                             <div style="padding:20px;">
                                 <h3 style="margin:0 0 20px 0" data-i18n="channelView.channelAnalytics">Аналитика канала</h3>
                                 <div id="channelAnalytics">
                                     <!-- Analytics will be loaded here -->
                                 </div>
                                 
                                 <div style="margin-top:30px;">
                                     <h3 style="margin:0 0 20px 0" data-i18n="channelView.channelAchievements">Достижения канала</h3>
                                     <div id="channelAchievements">
                                         <!-- Achievements will be loaded here -->
                                     </div>
                                 </div>
                             </div>
                         </div>

                         <div id="playlistsTab" class="tab-content">
                 <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:20px 20px 0 20px;">
                       <h3 data-i18n="channelView.channelPlaylists">Плейлисты канала</h3>
                       <div style="display:flex;align-items:center;gap:12px;">
                           <button id="createPlaylist" class="btn" data-i18n="playlists.createPlaylist">Создать плейлист</button>
                       </div>
                     </div>
                 <div id="playlistsGrid" class="playlists-grid" style="padding:0 20px 20px 20px;">
                     <!-- Playlists will be loaded here -->
                 </div>
             </div>

                         <div id="descriptionTab" class="tab-content">
                             <div style="padding:20px;">
                                 <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                                     <h3 style="margin:0" data-i18n="channelView.channelDescription">Описание канала</h3>
                                     <button id="editDescriptionBtn" class="btn primary" data-i18n="video.edit">Редактировать</button>
                                 </div>
                                 
                                 <div id="descriptionView" style="background:#fff;border-radius:8px;padding:20px;border:1px solid #eee;min-height:200px;">
                                     <div id="descriptionText" style="font-size:14px;line-height:1.6;color:#333;min-height:100px;" data-i18n="channelView.noDescription">Описание не задано</div>
                                 </div>
                                 
                                 <div id="descriptionEdit" style="display:none;background:#fff;border-radius:8px;padding:20px;border:1px solid #eee;">
                                     <div class="form-group" style="margin-bottom:16px;">
                                         <label for="descriptionTitle" style="display:block;margin-bottom:4px;font-weight:700;font-size:13px;color:#333;" data-i18n="channelView.descriptionTitleLabel">Заголовок описания</label>
                                         <input type="text" id="descriptionTitle" style="width:100%;padding:8px;border:1px solid rgba(0,0,0,0.1);border-radius:6px;font-family:Verdana;font-size:13px;" data-i18n-placeholder="channelView.descriptionTitlePlaceholder" placeholder="Краткий заголовок для описания">
                                     </div>
                                     
                                     <div class="form-group" style="margin-bottom:16px;">
                                         <label for="descriptionContent" style="display:block;margin-bottom:4px;font-weight:700;font-size:13px;color:#333;" data-i18n="channelView.descriptionContentLabel">Описание канала</label>
                                         
                                         <div class="editor-toolbar" id="descriptionToolbar" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px;">
                                             <button data-cmd="bold" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;"><b>B</b></button>
                                             <button data-cmd="italic" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;"><i>I</i></button>
                                             <button data-cmd="underline" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;"><u>U</u></button>
                                             <button data-cmd="insertUnorderedList" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;">• List</button>
                                             <button data-cmd="insertOrderedList" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;">1. List</button>
                                             <button data-cmd="formatBlock" data-value="h3" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;">H3</button>
                                             <button data-cmd="formatBlock" data-value="h4" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;">H4</button>
                                             <button id="createLinkBtn" style="padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;font-weight:700;">Link</button>
                                         </div>
                                         
                                         <div id="descriptionEditor" class="editor" contenteditable="true" data-i18n-placeholder="channelView.descriptionEditorPlaceholder" placeholder="Опишите ваш канал..." style="min-height:250px;border:1px solid rgba(0,0,0,0.08);border-radius:6px;padding:12px;background:#fff;overflow:auto;font-family:Verdana;font-size:13px;"></div>
                                     </div>
                                     
                                     <div style="display:flex;gap:8px;margin-top:12px;">
                                         <button class="btn primary" id="saveDescriptionBtn" data-i18n="video.save">Сохранить</button>
                                         <button class="btn" id="cancelDescriptionBtn" data-i18n="video.cancel">Отмена</button>
                                     </div>
                                 </div>
                             </div>
                         </div>

            <!-- Hidden file inputs -->
            <input type="file" id="avatarInput" class="file-input" accept="image/*" style="display:none;">
            <input type="file" id="headerInput" class="file-input" accept="image/*" style="display:none;">
            <input type="file" id="bgInput" class="file-input" accept="image/*" style="display:none;">
        
            <!-- Create Playlist Modal -->
            <div id="createPlaylistModal" class="modal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10001;padding:20px;">
                <div class="modal-content" style="background:#fff;border-radius:8px;max-width:700px;width:90%;margin:50px auto;padding:20px;max-height:85vh;overflow-y:auto;display:flex;flex-direction:column;">
                    <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid #eee">
                        <h3 style="margin:0;font-size:16px" data-i18n="playlists.createNewPlaylist">Создать новый плейлист</h3>
                        <button class="close-btn" data-close="create" style="background:none;border:none;font-size:24px;cursor:pointer;color:#666;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center">&times;</button>
                    </div>
                    <input type="text" id="newPlaylistTitle" class="playlist-input" data-i18n-placeholder="playlists.playlistName" placeholder="Название плейлиста" style="width:100%;padding:8px;margin-bottom:10px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                    <input type="text" id="newPlaylistCategories" class="playlist-input" data-i18n-placeholder="playlists.categoriesPlaceholder" placeholder="Категории через запятую (например: музыка, релакс)" style="width:100%;padding:8px;margin-bottom:15px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                    <div class="video-search" style="margin-bottom:8px">
                        <input type="text" id="videoSearch" data-i18n-placeholder="playlists.searchVideos" placeholder="Поиск видео..." style="width:100%;padding:4px 8px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                    </div>
                    <div style="display:flex;gap:6px;margin:4px 0 6px;align-items:center">
                        <button id="selectAllVideos" class="btn secondary" type="button" data-i18n="playlists.selectAll">Выбрать все на странице</button>
                        <button id="clearSelection" class="btn secondary" type="button" data-i18n="playlists.clearSelection">Снять выделение</button>
                        <div id="selectionCounter" style="margin-left:auto;font-size:12px;color:#7a3c55"><span data-i18n="playlists.selected">Выбрано</span>: 0</div>
                    </div>
                    <div class="video-list" id="videoList" style="max-height:350px;overflow-y:auto;border:1px solid #ddd;border-radius:4px;background:#fff;flex:1;min-height:200px;"></div>
                    <div class="modal-actions" style="display:flex;gap:6px;margin:8px 0;justify-content:flex-end">
                        <button id="cancelPlaylist" class="btn secondary" data-i18n="playlists.cancel">Отмена</button>
                        <button id="savePlaylist" class="btn primary" data-i18n="playlists.create">Создать</button>
                    </div>
                </div>
            </div>
        
            <!-- Edit Playlist Modal -->
            <div id="editPlaylistModal" class="modal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10001;padding:20px;">
                <div class="modal-content" style="background:#fff;border-radius:8px;max-width:700px;width:90%;margin:50px auto;padding:20px;max-height:85vh;overflow-y:auto;display:flex;flex-direction:column;">
                    <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid #eee">
                        <h3 style="margin:0;font-size:16px" data-i18n="playlists.editPlaylist">Редактировать плейлист</h3>
                        <button class="close-btn" data-close="edit" style="background:none;border:none;font-size:24px;cursor:pointer;color:#666;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center">&times;</button>
                    </div>
                    <input type="text" id="editPlaylistTitle" class="playlist-input" data-i18n-placeholder="playlists.playlistName" placeholder="Название плейлиста" style="width:100%;padding:8px;margin-bottom:10px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                    <input type="text" id="editPlaylistCategories" class="playlist-input" data-i18n-placeholder="playlists.categoriesPlaceholder" placeholder="Категории через запятую" style="width:100%;padding:8px;margin-bottom:15px;border:1px solid #ddd;border-radius:4px;font-size:12px">
        
                    <div style="display:flex;gap:8px;margin:8px 0;align-items:center;">
                        <h4 style="margin:0;font-size:14px;" data-i18n="playlists.videosInPlaylist">Видео в плейлисте:</h4>
                        <button id="addVideosToPlaylist" class="btn secondary" data-i18n="playlists.addVideos">Добавить видео</button>
                        <div id="playlistTypeInfo" style="margin-left:auto;font-size:11px;color:#666;">
                            <!-- Тип плейлиста будет обновлен динамически -->
                        </div>
                    </div>
        
                    <div class="video-search" style="margin-bottom:8px">
                        <input type="text" id="editPlaylistVideoSearch" data-i18n-placeholder="playlists.searchInPlaylist" placeholder="Поиск по видео в плейлисте..." style="width:100%;padding:4px 8px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                    </div>
                    <div id="editPlaylistVideosList" style="max-height:200px;overflow-y:auto;border:1px solid #ddd;border-radius:4px;background:#fff;margin-bottom:8px;user-select:none;"></div>
        
                    <div class="modal-actions" style="display:flex;gap:6px;margin:8px 0;justify-content:flex-end">
                        <button id="cancelEditPlaylist" class="btn secondary" data-i18n="playlists.cancel">Отмена</button>
                        <button id="saveEditPlaylist" class="btn primary" data-i18n="playlists.save">Сохранить</button>
                    </div>
                </div>
            </div>
        
            <!-- Add Videos Modal (for editing) -->
            <div id="addVideosModal" class="modal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10001;padding:20px;">
                <div class="modal-content" style="background:#fff;border-radius:8px;max-width:700px;width:90%;margin:50px auto;padding:20px;max-height:85vh;overflow-y:auto;display:flex;flex-direction:column;">
                    <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid #eee">
                        <h3 style="margin:0;font-size:16px" data-i18n="playlists.addToPlaylist">Добавить видео в плейлист</h3>
                        <button class="close-btn" data-close="addVideos" style="background:none;border:none;font-size:24px;cursor:pointer;color:#666;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center">&times;</button>
                    </div>
                    <div class="video-search" style="margin-bottom:8px">
                        <input type="text" id="addVideoSearch" data-i18n-placeholder="playlists.searchVideos" placeholder="Поиск видео..." style="width:100%;padding:4px 8px;border:1px solid #ddd;border-radius:4px;font-size:12px">
                        <div class="search-info" style="font-size:11px;color:#666;margin-top:4px;text-align:center;">
                            <!-- Информация о доступных видео будет обновлена динамически -->
                        </div>
                    </div>
                    <div style="display:flex;gap:6px;margin:4px 0 6px;align-items:center">
                        <button id="selectAllAddVideos" class="btn secondary" data-i18n="playlists.selectAll">Выбрать все на странице</button>
                        <button id="clearAddSelection" class="btn secondary" data-i18n="playlists.clearSelection">Снять выделение</button>
                        <div id="addSelectionCounter" style="margin-left:auto;font-size:12px;color:#7a3c55"><span data-i18n="playlists.selected">Выбрано</span>: 0</div>
                    </div>
                    <div class="video-list" id="addVideoList" style="max-height:350px;overflow-y:auto;border:1px solid #ddd;border-radius:4px;background:#fff;"></div>
                    <div class="modal-actions" style="display:flex;gap:6px;margin:8px 0;justify-content:flex-end">
                        <button id="cancelAddVideos" class="btn secondary" data-i18n="playlists.cancel">Отмена</button>
                        <button id="confirmAddVideos" class="btn primary" data-i18n="playlists.addSelectedVideos">Добавить выбранные</button>
                    </div>
                </div>
            </div>

            <!-- Birthday Modal -->
            <div id="birthdayModal" class="modal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10001;padding:20px;">
                <div class="modal-content" style="background:#fff;border-radius:8px;max-width:400px;width:90%;margin:100px auto;padding:20px;">
                    <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid #eee">
                        <h3 style="margin:0;font-size:16px" data-i18n="channelView.setBirthday">Указать день рождения</h3>
                        <button class="close-btn" data-close="birthday" style="background:none;border:none;font-size:24px;cursor:pointer;color:#666;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center">&times;</button>
                    </div>
                    <div style="display:flex;flex-direction:column;gap:12px;">
                        <div>
                            <label style="display:block;margin-bottom:4px;font-weight:600;font-size:13px;color:#333;" data-i18n="channelView.month">Месяц</label>
                            <select id="birthdayMonth" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:13px;">
                                <option value="" data-i18n="channelView.selectMonth">Выберите месяц</option>
                                <option value="1" data-i18n-month="0">Январь</option>
                                <option value="2" data-i18n-month="1">Февраль</option>
                                <option value="3" data-i18n-month="2">Март</option>
                                <option value="4" data-i18n-month="3">Апрель</option>
                                <option value="5" data-i18n-month="4">Май</option>
                                <option value="6" data-i18n-month="5">Июнь</option>
                                <option value="7" data-i18n-month="6">Июль</option>
                                <option value="8" data-i18n-month="7">Август</option>
                                <option value="9" data-i18n-month="8">Сентябрь</option>
                                <option value="10" data-i18n-month="9">Октябрь</option>
                                <option value="11" data-i18n-month="10">Ноябрь</option>
                                <option value="12" data-i18n-month="11">Декабрь</option>
                            </select>
                        </div>
                        <div>
                            <label style="display:block;margin-bottom:4px;font-weight:600;font-size:13px;color:#333;" data-i18n="channelView.day">День</label>
                            <select id="birthdayDay" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:13px;">
                                <option value="" data-i18n="channelView.selectDay">Выберите день</option>
                            </select>
                        </div>
                        <div>
                            <label style="display:block;margin-bottom:4px;font-weight:600;font-size:13px;color:#333;" data-i18n="channelView.yearOptional">Год (необязательно)</label>
                            <input type="number" id="birthdayYear" data-i18n-placeholder="channelView.yearPlaceholder" placeholder="Например: 1990" min="1900" max="2024" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:13px;">
                        </div>
                    </div>
                    <div class="modal-actions" style="display:flex;gap:8px;margin-top:15px;justify-content:flex-end">
                        <button id="clearBirthday" class="btn secondary" data-i18n="channelView.clear">Очистить</button>
                        <button id="cancelBirthday" class="btn secondary" data-i18n="channelView.cancel">Отмена</button>
                        <button id="saveBirthday" class="btn primary" data-i18n="channelView.save">Сохранить</button>
                    </div>
                </div>
            </div>
        </main>
        </div><!-- /content-wrapper -->
    </div>

   <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <img src="images/logo_youvi_ind_ex.png" alt="Youvi" loading="lazy">
                    <p data-i18n="footer.description">Платформа для просмотра видео контента. Сохраняйте, категоризируйте и смотрите видео.</p>
                </div>
                <div class="footer-sections">
                    <div class="footer-section">
                        <h3 data-i18n="footer.sections">Разделы</h3>
            <ul>
              <li><a href="youvi_main.html" data-i18n="footer.video">Видео</a></li>
              <li><a href="youvi_tags.html" data-i18n="footer.tags">Теги</a></li>
              <li><a href="forum/forum.html" >Форумы</a></li>
              <li><a href="index.html" data-i18n="footer.management">Управление</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.library">Библиотека</h3>
            <ul>
              <li><a href="youvi_ch_list.html" data-i18n="footer.channels">Каналы</a></li>
              <li><a href="youvi_playlists_list.html" data-i18n="footer.playlists">Плейлисты</a></li>
              <li><a href="youvi_subscriptions.html" data-i18n="footer.subscriptions">Подписки</a></li>
              <li><a href="youvi_fav.html" data-i18n="footer.favorites">Избранное</a></li>
              <li><a href="youvi_history.html" data-i18n="footer.history">История</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3>Wiki</h3>
            <ul>
              <li><a href="wiki/index.html" data-i18n="sidebar.home">Главная</a></li>
              <li><a href="wiki/player.html" data-i18n="footer.wiki.player">Плеер</a></li>
              <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku">Данмаку</a></li>
              <li><a href="wiki/tags/general.html" data-i18n="sidebar.tags">Теги</a></li>
              <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules">Правила тегирования</a></li>
              <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search">Поиск</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.pgc">PGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
              <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
              <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
              <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
              <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.ugc">UGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
              <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
              <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
              <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
              <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
              <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
              <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.about">О сайте</h3>
            <ul>
              <li><a href="wiki/about.html" data-i18n="footer.aboutSite">Про сайт</a></li>
               <li><a href="wiki/docs.html" data-i18n="footer.docs">Документация</a></li>
              <li><a href="wiki/tech.html" data-i18n="footer.tech">Технологии</a></li>
            </ul>
                    </div>
                </div>
            </div>
            <div class="footer-right">
                <div class="footer-mascot">
                    <img src="images/mascot1.png" alt="Yuvi" loading="lazy">
                </div>
            </div>
        </div>
 
    </footer>

    <script>
        // Debug flag for channel view logs
        const CHANNEL_VIEW_DEBUG = false;
        
        async function loadSubscriptionsFromFile() {
            try {
                const localSubscriptions = localStorage.getItem('8site_subscriptions');
                if (localSubscriptions && localSubscriptions !== 'null' && localSubscriptions !== 'undefined') {
                    const parsed = JSON.parse(localSubscriptions);
                    if (Array.isArray(parsed)) return parsed;
                }

                if (videoDirectoryHandle) {
                    try {
                        const fileHandle = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        const fileSubscriptions = JSON.parse(text);
                        if (Array.isArray(fileSubscriptions)) {
                            localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
                            return fileSubscriptions;
                        }
                    } catch (fileError) {
                        if (CHANNEL_VIEW_DEBUG) console.log('Could not load from .subscriptions:', fileError.message);
                    }
                }

                return [];
            } catch (e) {
                console.error('Error loading subscriptions:', e);
                return [];
            }
        }

        async function loadChannelAvatar(channelName) {
            const cacheKey = `avatar_${channelName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
            }

            try {
                if (videoDirectoryHandle) {
                    const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                    const channelDir = await channelsDir.getDirectoryHandle(channelName, { create: true });
                    const channelData = await readJSONFile(channelDir, 'channel.json', {});

                    if (channelData.avatar) {
                        const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                        if (avatarUrl) {
                            avatarCache.set(cacheKey, {
                                url: avatarUrl,
                                timestamp: Date.now()
                            });
                            return avatarUrl;
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading avatar for', channelName, e);
            }

            return null;
        }

        async function renderSubscribedChannelsList() {
            const container = document.getElementById('subscribedChannelsContainer');
            if (!container) return;

            try {
                const subscriptions = await loadSubscriptionsFromFile();

                if (!subscriptions || subscriptions.length === 0) {
                    container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">Нет подписок</div>';
                    return;
                }

                container.innerHTML = '';

                for (const channelName of subscriptions.slice(0, 10)) {
                    const link = document.createElement('a');
                    link.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
                    link.className = 'sidebar-item';
                    link.style.display = 'flex';
                    link.style.alignItems = 'center';
                    link.style.gap = '8px';
                    link.style.cursor = 'pointer';
                    link.style.paddingTop = '6px';
                    link.style.paddingBottom = '6px';

                    const avatarDiv = document.createElement('div');
                    avatarDiv.style.width = '20px';
                    avatarDiv.style.height = '20px';
                    avatarDiv.style.borderRadius = '0';
                    avatarDiv.style.background = '#ff69b4';
                    avatarDiv.style.display = 'flex';
                    avatarDiv.style.alignItems = 'center';
                    avatarDiv.style.justifyContent = 'center';
                    avatarDiv.style.fontSize = '10px';
                    avatarDiv.style.color = 'white';
                    avatarDiv.style.fontWeight = 'bold';
                    avatarDiv.style.flexShrink = '0';
                    avatarDiv.textContent = channelName.charAt(0).toUpperCase();

                    const nameSpan = document.createElement('span');
                    nameSpan.style.flex = '1';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    nameSpan.textContent = channelName;

                    link.appendChild(avatarDiv);
                    link.appendChild(nameSpan);
                    container.appendChild(link);

                    loadChannelAvatar(channelName).then(avatarUrl => {
                        if (avatarUrl) {
                            avatarDiv.style.background = 'none';
                            avatarDiv.style.backgroundImage = `url(${avatarUrl})`;
                            avatarDiv.style.backgroundSize = 'cover';
                            avatarDiv.style.backgroundPosition = 'center';
                            avatarDiv.textContent = '';
                        }
                    });
                }

                if (subscriptions.length > 10) {
                    const moreLink = document.createElement('a');
                    moreLink.href = 'youvi_subscriptions.html';
                    moreLink.className = 'sidebar-item';
                    moreLink.style.fontSize = '11px';
                    moreLink.style.color = '#666';
                    moreLink.style.textAlign = 'center';
                    moreLink.textContent = `+${subscriptions.length - 10} еще`;
                    container.appendChild(moreLink);
                }
            } catch (e) {
                console.error('Error rendering subscriptions:', e);
                container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">Ошибка загрузки</div>';
            }
        }

        
        const supportsFS = 'showDirectoryPicker' in window;
        let videoDirectoryHandle = null;
        let currentChannelName = null;
        let channelData = {};
        let channelVideos = [];
        let channelVideosLoaded = false;
        let currentSort = 'default';

        let selectedVideoIds = new Set();
        let editingSelectedVideos = new Set();
        let currentEditingPlaylist = null;

        function getCurrentSortType() {
            return currentSort;
        }
        let createModalVideoOrder = [];
        
        const RENDER_THROTTLE = 16;
        const BATCH_SIZE = 50;
        const VISIBLE_ITEMS = 30;
        const BUFFER_SIZE = VISIBLE_ITEMS * 2;
        const LAZY_LOAD_MARGIN = 100;
        const MAX_PREVIEW_CACHE = 50;
        const MAX_OBSERVER_ITEMS = 100;
        const CHANNEL_VIDEOS_CACHE_TTL = 30 * 60 * 1000;
        
        const videoCache = new Map();
        const metadataCache = new Map();
        const previewCache = new Map();
        const avatarCache = new Map();
        const headerCache = new Map();
        let lastRenderTime = 0;
        
        let channelAnalytics = {
            views: 0,
            subscribers: 0,
            totalWatchTime: 0,
            popularVideos: [],
            viewerRetention: {},
            uploadSchedule: [],
            engagementRate: 0,
            lastUpdate: 0,
            videoCount: 0
        };
        
        class OptimizedLazyLoader {
            constructor() {
                this.observers = new Map();
                this.pendingVideos = new Map();
                this.observerCount = 0;
                this.maxObservers = 5;
                this.initObserver();
            }
            
            initObserver() {
                if (!('IntersectionObserver' in window)) return;
                
                for (let i = 0; i < this.maxObservers; i++) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const videoName = entry.target.dataset.videoName;
                                const videoData = this.pendingVideos.get(videoName);
                                if (videoData) {
                                    this.loadVideoPreview(videoData.video, videoData.thumbnailElement, videoData.priority);
                                    this.pendingVideos.delete(videoName);
                                    observer.unobserve(entry.target);
                                }
                            }
                        });
                    }, {
                        rootMargin: `${LAZY_LOAD_MARGIN}px`,
                        threshold: 0.1
                    });
                    
                    this.observers.set(i, observer);
                }
            }
            
            addVideo(video, thumbnailElement, priority = 0) {
                if (this.observers.size === 0) {
                    this.loadVideoPreview(video, thumbnailElement, priority);
                    return;
                }
                
                if (this.pendingVideos.size >= MAX_OBSERVER_ITEMS) {
                    const oldestKey = this.pendingVideos.keys().next().value;
                    this.pendingVideos.delete(oldestKey);
                }
                
                thumbnailElement.dataset.videoName = video.name;
                this.pendingVideos.set(video.name, { video, thumbnailElement, priority });
                
                const observerIndex = this.observerCount % this.maxObservers;
                const observer = this.observers.get(observerIndex);
                if (observer) {
                    observer.observe(thumbnailElement);
                    this.observerCount++;
                }
            }
            
            async loadVideoPreview(video, thumbnailElement, priority = 0) {
                try {
                    const cacheKey = `${video.name}_${video.size}_${video.modified}`;
                    if (previewCache.has(cacheKey)) {
                        const cached = previewCache.get(cacheKey);
                        if (cached.preview && cached.preview !== null && cached.preview.length > 50 && !cached.preview.includes('blob:null/')) {
                            thumbnailElement.innerHTML = `<img src="${cached.preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';" />`;
                            this.addBadges(thumbnailElement, cached.duration, video);
                            return;
                        } else {
                            previewCache.delete(cacheKey);
                        }
                    }
                    
                    const { preview, duration } = await getPreviewAndDuration(video);
                    
                    if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                        if (previewCache.size >= MAX_PREVIEW_CACHE) {
                            const entries = Array.from(previewCache.entries());
                            entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
                            const toDelete = entries.slice(MAX_PREVIEW_CACHE / 2);
                            toDelete.forEach(([key]) => previewCache.delete(key));
                        }
                        
                        previewCache.set(cacheKey, { 
                            preview, 
                            duration, 
                            timestamp: Date.now() 
                        });
                        
                        thumbnailElement.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';" />`;
                        this.addBadges(thumbnailElement, duration, video);
                    } else {
                        thumbnailElement.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:10px;text-align:center;padding:5px;">
                            ${getFileNameWithoutExtension(video.name)}
                        </div>`;
                        this.addBadges(thumbnailElement, duration, video);
                    }
                } catch (e) {
                    console.error('Error loading preview:', e);
                    thumbnailElement.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:10px;text-align:center;padding:5px;">
                        ${getFileNameWithoutExtension(video.name)}
                    </div>`;
                }
            }
            
            addBadges(thumbnailElement, duration, video) {
                const durationBadge = document.createElement('div');
                durationBadge.className = 'video-duration';
                durationBadge.textContent = duration;
                thumbnailElement.appendChild(durationBadge);
                
                if (video.quality) {
                    const qualityBadge = document.createElement('div');
                    qualityBadge.className = 'video-quality';
                    qualityBadge.textContent = video.quality;
                    thumbnailElement.appendChild(qualityBadge);
                }
                
                if (video.created && (Date.now() - video.created) < 24 * 60 * 60 * 1000) {
                    const newBadge = document.createElement('div');
                    newBadge.className = 'video-new';
                    newBadge.textContent = typeof i18n !== 'undefined' ? i18n.t('badges.new') : 'Новинка';
                    thumbnailElement.appendChild(newBadge);
                }
            }
            
            cleanup() {
                this.observers.forEach(observer => observer.disconnect());
                this.observers.clear();
                this.pendingVideos.clear();
            }
        }
        
        class OptimizedChannelAnalytics {
            constructor(channelName) {
                this.channelName = channelName;
                this.data = {
                    views: 0,
                    subscribers: 0,
                    totalWatchTime: 0,
                    popularVideos: [],
                    viewerRetention: {},
                    uploadSchedule: [],
                    engagementRate: 0,
                    lastUpdated: Date.now(),
                    videoCount: 0,
                    totalLikes: 0,
                    totalDislikes: 0
                };
                this.lastVideoCount = 0;
                this.lastViews = 0;
                this.lastLikes = 0;
                this.lastDislikes = 0;
            }
            
            async updateAnalytics(videos, forceUpdate = false) {
                const currentVideoCount = videos.length;
                const currentViews = videos.reduce((sum, v) => sum + (v.views || 0), 0);
                const currentLikes = videos.reduce((sum, v) => sum + (v.likes || 0), 0);
                const currentDislikes = videos.reduce((sum, v) => sum + (v.dislikes || 0), 0);
                
                if (!forceUpdate && 
                    currentVideoCount === this.lastVideoCount &&
                    currentViews === this.lastViews &&
                    currentLikes === this.lastLikes &&
                    currentDislikes === this.lastDislikes) {
                    return this.data;
                }
                
                if (currentVideoCount !== this.lastVideoCount) {
                    this.data.videoCount = currentVideoCount;
                    this.data.uploadSchedule = this.analyzeUploadSchedule(videos);
                }
                
                if (currentViews !== this.lastViews) {
                    this.data.views = currentViews;
                    this.data.totalWatchTime = videos.reduce((sum, v) => sum + (v.duration || 0) * (v.views || 0), 0);
                }
                
                if (currentLikes !== this.lastLikes || currentDislikes !== this.lastDislikes) {
                    this.data.totalLikes = currentLikes;
                    this.data.totalDislikes = currentDislikes;
                    this.data.engagementRate = this.data.views > 0 ? 
                        ((currentLikes + currentDislikes) / this.data.views * 100) : 0;
                }
                
                if (Math.abs(currentViews - this.lastViews) > this.data.views * 0.1) {
                    this.data.popularVideos = this.getPopularVideos(videos);
                }
                
                this.data.subscribers = await this.getSubscriberCount();
                
                this.data.lastUpdated = Date.now();
                
                this.lastVideoCount = currentVideoCount;
                this.lastViews = currentViews;
                this.lastLikes = currentLikes;
                this.lastDislikes = currentDislikes;
                
                return this.data;
            }
            
            getPopularVideos(videos) {
                return [...videos]
                    .sort((a, b) => (b.views || 0) - (a.views || 0))
                    .slice(0, 5)
                    .map(v => ({
                        name: v.name,
                        views: v.views || 0,
                        title: getFileNameWithoutExtension(v.name)
                    }));
            }
            
            async getSubscriberCount() {
                try {
                    const subscriptions = await loadSubscriptionsFromFile();
                    return subscriptions ? subscriptions.length : 0;
                } catch (e) {
                    return 0;
                }
            }
            
                          analyzeUploadSchedule(videos) {
                  if (!videos || videos.length === 0) {
                      return {
                          bestDay: 'Понедельник',
                          bestHour: 12,
                          totalUploads: 0,
                          averageUploadsPerWeek: 0
                      };
                  }
                  
                  const uploadsByDay = new Array(7).fill(0);
                  const uploadsByHour = new Array(24).fill(0);
                  
                  videos.forEach(video => {
                      const date = new Date(video.created || video.modified || Date.now());
                      if (!isNaN(date.getTime())) {
                          uploadsByDay[date.getDay()]++;
                          uploadsByHour[date.getHours()]++;
                      }
                  });
                  
                  const bestDay = uploadsByDay.indexOf(Math.max(...uploadsByDay));
                  const bestHour = uploadsByHour.indexOf(Math.max(...uploadsByHour));
                  
                  const now = Date.now();
                  const videoDates = videos.map(v => v.created || v.modified || now).filter(d => !isNaN(d));
                  const oldestDate = videoDates.length > 0 ? Math.min(...videoDates) : now;
                  const weeksSinceOldest = Math.max(1, (now - oldestDate) / (7 * 24 * 60 * 60 * 1000));
                  const averageUploadsPerWeek = videos.length / weeksSinceOldest;
                  
                  return {
                      bestDay: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'][bestDay] || 'Понедельник',
                      bestHour: bestHour >= 0 ? bestHour : 12,
                      totalUploads: videos.length,
                      averageUploadsPerWeek: isFinite(averageUploadsPerWeek) ? averageUploadsPerWeek : 0
                  };
              }
            
            renderAnalytics() {
                const analyticsContainer = document.getElementById('channelAnalytics');
                if (!analyticsContainer) return;
                
                analyticsContainer.innerHTML = `
                    <div class="analytics-grid">
                        <div class="analytics-card">
                            <div class="analytics-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                    <circle cx="12" cy="12" r="3"/>
                                </svg>
                            </div>
                            <div class="analytics-value">${this.data.views.toLocaleString()}</div>
                            <div class="analytics-label">views</div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                                    <circle cx="9" cy="7" r="4"/>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                                </svg>
                            </div>
                            <div class="analytics-value">${this.data.subscribers}</div>
                            <div class="analytics-label">${typeof i18n !== 'undefined' ? i18n.t('channelView.subscribers') : 'Подписчиков'}</div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <polyline points="12,6 12,12 16,14"/>
                                </svg>
                            </div>
                                                         <div class="analytics-value">${this.formatWatchTime(this.data.totalWatchTime || 0)}</div>
                            <div class="analytics-label">${typeof i18n !== 'undefined' ? i18n.t('channelView.watchTime') : 'Время просмотра'}</div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                                    <polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
                                </svg>
                            </div>
                                                         <div class="analytics-value">${(this.data.engagementRate || 0).toFixed(1)}%</div>
                            <div class="analytics-label">${typeof i18n !== 'undefined' ? i18n.t('channelView.engagement') : 'Вовлеченность'}</div>
                        </div>
                    </div>
                    
                    <div class="analytics-sections">
                        <div class="analytics-section">
                            <h4>${typeof i18n !== 'undefined' ? i18n.t('channelView.popularVideos') : 'Популярные видео'}</h4>
                            <div class="popular-videos">
                                ${this.data.popularVideos.map((video, index) => `
                                    <div class="popular-video">
                                        <span class="rank">${index + 1}</span>
                                        <span class="title">${video.title}</span>
                                        <span class="views">${video.views.toLocaleString()} views</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="analytics-section">
                            <h4>${typeof i18n !== 'undefined' ? i18n.t('channelView.uploadSchedule') : 'Расписание загрузок'}</h4>
                            <div class="upload-schedule">
                                <div class="schedule-item">
                                    <span class="label">${typeof i18n !== 'undefined' ? i18n.t('channelView.bestDay') : 'Лучший день'}:</span>
                                                                         <span class="value">${this.getDayName(this.data.uploadSchedule?.bestDay)}</span>
                                </div>
                                <div class="schedule-item">
                                    <span class="label">${typeof i18n !== 'undefined' ? i18n.t('channelView.bestTime') : 'Лучшее время'}:</span>
                                                                         <span class="value">${this.data.uploadSchedule?.bestHour || 12}:00</span>
                                </div>
                                <div class="schedule-item">
                                    <span class="label">${typeof i18n !== 'undefined' ? i18n.t('channelView.totalVideos') : 'Всего видео'}:</span>
                                                                         <span class="value">${this.data.uploadSchedule?.totalUploads || 0}</span>
                                </div>
                                <div class="schedule-item">
                                    <span class="label">${typeof i18n !== 'undefined' ? i18n.t('channelView.perWeek') : 'В неделю'}:</span>
                                                                         <span class="value">${(this.data.uploadSchedule?.averageUploadsPerWeek || 0).toFixed(1)}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            formatWatchTime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const days = Math.floor(hours / 24);
                if (days > 0) return `${days}д ${hours % 24}ч`;
                if (hours > 0) return `${hours}ч ${Math.floor((seconds % 3600) / 60)}м`;
                return `${Math.floor(seconds / 60)}м`;
            }
            
            getDayName(day) {
                if (!day) {
                    return typeof i18n !== 'undefined' ? i18n.t('channelView.monday') : 'Понедельник';
                }
                const dayMap = {
                    'Понедельник': 'monday',
                    'Вторник': 'tuesday',
                    'Среда': 'wednesday',
                    'Четверг': 'thursday',
                    'Пятница': 'friday',
                    'Суббота': 'saturday',
                    'Воскресенье': 'sunday',
                    'Monday': 'monday',
                    'Tuesday': 'tuesday',
                    'Wednesday': 'wednesday',
                    'Thursday': 'thursday',
                    'Friday': 'friday',
                    'Saturday': 'saturday',
                    'Sunday': 'sunday'
                };
                const key = dayMap[day] || 'monday';
                return typeof i18n !== 'undefined' ? i18n.t(`channelView.${key}`) : day;
            }
        }
        
        class VirtualScroller {
            constructor(container, itemHeight = 200) {
                this.container = container;
                this.itemHeight = itemHeight;
                this.items = [];
                this.visibleItems = [];
                this.scrollTop = 0;
                this.containerHeight = 0;
                this.init();
            }
            
            init() {
                this.container.style.position = 'relative';
                this.container.style.overflow = 'auto';
                this.container.addEventListener('scroll', this.onScroll.bind(this));
                this.updateContainerHeight();
            }
            
            setItems(items) {
                this.items = items;
                this.updateContainerHeight();
                this.render();
            }
            
            updateContainerHeight() {
                this.containerHeight = this.items.length * this.itemHeight;
                this.container.style.height = `${this.containerHeight}px`;
            }
            
            onScroll() {
                this.scrollTop = this.container.scrollTop;
                this.render();
            }
            
            render() {
                const startIndex = Math.floor(this.scrollTop / this.itemHeight);
                const endIndex = Math.min(startIndex + Math.ceil(this.container.clientHeight / this.itemHeight) + 1, this.items.length);
                
                this.container.innerHTML = '';
                
                const wrapper = document.createElement('div');
                wrapper.style.position = 'absolute';
                wrapper.style.top = `${startIndex * this.itemHeight}px`;
                wrapper.style.left = '0';
                wrapper.style.right = '0';
                
                for (let i = startIndex; i < endIndex; i++) {
                    const item = this.items[i];
                    if (item) {
                        const itemElement = this.createItemElement(item, i);
                        wrapper.appendChild(itemElement);
                    }
                }
                
                this.container.appendChild(wrapper);
            }
            
            createItemElement(item, index) {
                const element = document.createElement('div');
                element.style.height = `${this.itemHeight}px`;
                element.textContent = `Item ${index + 1}`;
                return element;
            }
        }
        
        class TaskQueue {
            constructor(concurrency = 3) {
                this.concurrency = concurrency;
                this.running = 0;
                this.queue = [];
            }
            
            async add(task, priority = 0) {
                return new Promise((resolve, reject) => {
                    this.queue.push({ task, priority, resolve, reject });
                    this.queue.sort((a, b) => b.priority - a.priority);
                    this.process();
                });
            }
            
            async process() {
                if (this.running >= this.concurrency || this.queue.length === 0) {
                    return;
                }
                
                this.running++;
                const { task, resolve, reject } = this.queue.shift();
                
                try {
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.running--;
                    this.process();
                }
            }
        }
        
        class ChannelAchievements {
            constructor() {
                this.achievements = [
                    {
                        id: 'first_video',
                        titleKey: 'channelView.firstStep',
                        descKey: 'channelView.firstStepDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                            <line x1="8" y1="21" x2="16" y2="21"/>
                            <line x1="12" y1="17" x2="12" y2="21"/>
                        </svg>`,
                        condition: (data) => data.videoCount >= 1,
                        unlocked: false
                    },
                    {
                        id: 'ten_videos',
                        titleKey: 'channelView.beginnerAuthor',
                        descKey: 'channelView.beginnerAuthorDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <polygon points="23,7 16,12 23,17 23,7"/>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                        </svg>`,
                        condition: (data) => data.videoCount >= 10,
                        unlocked: false
                    },
                    {
                        id: 'hundred_views',
                        titleKey: 'channelView.firstViewers',
                        descKey: 'channelView.firstViewersDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>`,
                        condition: (data) => data.views >= 100,
                        unlocked: false
                    },
                    {
                        id: 'thousand_views',
                        titleKey: 'channelView.popularity',
                        descKey: 'channelView.popularityDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26 12,2"/>
                        </svg>`,
                        condition: (data) => data.views >= 1000,
                        unlocked: false
                    },
                    {
                        id: 'first_subscriber',
                        titleKey: 'channelView.firstSubscriber',
                        descKey: 'channelView.firstSubscriberDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                            <circle cx="12" cy="7" r="4"/>
                        </svg>`,
                        condition: (data) => data.subscribers >= 1,
                        unlocked: false
                    },
                    {
                        id: 'ten_subscribers',
                        titleKey: 'channelView.growingAudience',
                        descKey: 'channelView.growingAudienceDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                            <circle cx="9" cy="7" r="4"/>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                        </svg>`,
                        condition: (data) => data.subscribers >= 10,
                        unlocked: false
                    },
                    {
                        id: 'weekly_uploader',
                        titleKey: 'channelView.regularity',
                        descKey: 'channelView.regularityDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" y1="2" x2="16" y2="6"/>
                            <line x1="8" y1="2" x2="8" y2="6"/>
                            <line x1="3" y1="10" x2="21" y2="10"/>
                        </svg>`,
                        condition: (data) => data.uploadSchedule.averageUploadsPerWeek >= 1,
                        unlocked: false
                    },
                    {
                        id: 'high_engagement',
                        titleKey: 'channelView.engagement',
                        descKey: 'channelView.engagementDesc',
                        icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d94b88" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                        </svg>`,
                        condition: (data) => data.engagementRate >= 5,
                        unlocked: false
                    }
                ];
            }

            getTitle(achievement) {
                return typeof i18n !== 'undefined' ? i18n.t(achievement.titleKey) : achievement.titleKey;
            }

            getDescription(achievement) {
                return typeof i18n !== 'undefined' ? i18n.t(achievement.descKey) : achievement.descKey;
            }

            checkAchievements(analyticsData) {
                const newlyUnlocked = [];
                
                this.achievements.forEach(achievement => {
                    if (!achievement.unlocked && achievement.condition(analyticsData)) {
                        achievement.unlocked = true;
                        newlyUnlocked.push(achievement);
                    }
                });
                
                return newlyUnlocked;
            }

            renderAchievements() {
                const container = document.getElementById('channelAchievements');
                if (!container) return;
                
                const unlockedCount = this.achievements.filter(a => a.unlocked).length;
                const totalCount = this.achievements.length;
                
                const achievementsLabel = typeof i18n !== 'undefined' ? i18n.t('channelView.achievements') : 'Достижения';
                
                container.innerHTML = `
                    <div class="achievements-header">
                        <h4>${achievementsLabel} (${unlockedCount}/${totalCount})</h4>
                        <div class="achievements-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${(unlockedCount / totalCount) * 100}%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="achievements-grid">
                        ${this.achievements.map(achievement => `
                            <div class="achievement ${achievement.unlocked ? 'unlocked' : 'locked'}">
                                <div class="achievement-icon">${achievement.icon}</div>
                                <div class="achievement-info">
                                    <div class="achievement-title">${this.getTitle(achievement)}</div>
                                    <div class="achievement-description">${this.getDescription(achievement)}</div>
                                </div>
                                <div class="achievement-status">
                                    ${achievement.unlocked ? 
                                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#4caf50" stroke-width="2"><polyline points="20,6 9,17 4,12"/></svg>' : 
                                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><circle cx="12" cy="16" r="1"/></svg>'
                                    }
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }

        const lazyLoader = new OptimizedLazyLoader();
        const taskQueue = new TaskQueue(3);
        let channelAnalyticsInstance = null;
        let channelAchievementsInstance = null;

        function clearOldCache() {
            const now = Date.now();
            const maxAge = 5 * 60 * 1000;
            
            for (const [key, value] of videoCache.entries()) {
                if (now - value.timestamp > maxAge) {
                    videoCache.delete(key);
                }
            }
            
            if (previewCache.size > MAX_PREVIEW_CACHE) {
                const entries = Array.from(previewCache.entries());
                entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
                const toDelete = entries.slice(MAX_PREVIEW_CACHE);
                toDelete.forEach(([key]) => previewCache.delete(key));
            }
            
            if (metadataCache.size > 200) {
                const entries = Array.from(metadataCache.entries());
                entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
                const toDelete = entries.slice(200);
                toDelete.forEach(([key]) => metadataCache.delete(key));
            }
            
            if (avatarCache.size > 20) {
                const entries = Array.from(avatarCache.entries());
                entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
                const toDelete = entries.slice(20);
                toDelete.forEach(([key]) => avatarCache.delete(key));
            }
            
            if (headerCache.size > 20) {
                const entries = Array.from(headerCache.entries());
                entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
                const toDelete = entries.slice(20);
                toDelete.forEach(([key]) => headerCache.delete(key));
            }
        }

        setInterval(clearOldCache, 2 * 60 * 1000);
        
        window.addEventListener('beforeunload', () => {
            lazyLoader.cleanup();
            clearOldCache();
        });


        function getUrlParam(param) {
            return new URLSearchParams(window.location.search).get(param);
        }

        function updateURLWithTab(tabName) {
            if (!currentChannelName) return;
            
            const url = new URL(window.location);
            url.searchParams.set('tab', tabName);
            
            window.history.replaceState({}, '', url);
        }

        async function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('8SiteDB', 1);
                request.onupgradeneeded = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains('handles')) {
                        db.createObjectStore('handles');
                    }
                    if (!db.objectStoreNames.contains('subscriptions')) {
                        db.createObjectStore('subscriptions');
                    }
                    if (!db.objectStoreNames.contains('videos')) {
                        db.createObjectStore('videos');
                    }
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getFromDB(db, key) {
            const storeName = key === 'subscriptions' ? 'subscriptions' : 'handles';
            
            if (!db.objectStoreNames.contains(storeName)) {
                return null;
            }
            
            const tx = db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            return new Promise((resolve) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(null);
            });
        }

        async function getFromDBGeneric(db, storeName, key) {
            if (!db || !storeName || !key || typeof key !== 'string' || key.length === 0) {
                return null;
            }
            
            try {
                if (!db.objectStoreNames.contains(storeName)) {
                    return null;
                }
                
                const tx = db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                return new Promise((resolve) => {
                    const r = store.get(key);
                    r.onsuccess = () => resolve(r.result);
                    r.onerror = () => resolve(null);
                });
            } catch (e) {
                console.warn('Failed to access IndexedDB store:', storeName, key, e);
                return null;
            }
        }

        async function getFromDBCompat(db, key) {
            if (!db || !key || typeof key !== 'string' || key.length === 0) {
                return null;
            }
            
            try {
                const tx = db.transaction('handles', 'readonly');
                const store = tx.objectStore('handles');
                return new Promise((resolve) => {
                    const r = store.get(key);
                    r.onsuccess = () => resolve(r.result);
                    r.onerror = () => resolve(null);
                });
            } catch (e) {
                console.warn('Failed to access handles store for key:', key, e);
                return null;
            }
        }

        async function getAllVideosFromDB() {
            try {
                const db = await openDB();
                if (!db.objectStoreNames.contains('videos')) {
                    return [];
                }
                const tx = db.transaction('videos', 'readonly');
                const store = tx.objectStore('videos');
                return new Promise((resolve) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                });
            } catch (e) {
                console.warn('Failed to get videos from DB:', e);
                return [];
            }
        }

        function saveChannelVideosCache(channelName, videos) {
            try {
                const cacheData = {
                    timestamp: Date.now(),
                    videos: videos.map(v => ({
                        name: v.name,
                        playlist: v.playlist || '',
                        views: v.views || 0,
                        likes: v.likes || 0,
                        created: v.created,
                        modified: v.modified,
                        tags: v.tags || [],
                        quality: v.quality || '',
                        duration: v.duration || 0,
                        preview: v.preview || null
                    }))
                };
                localStorage.setItem(`channelVideos_${channelName}`, JSON.stringify(cacheData));
                if (CHANNEL_VIEW_DEBUG) console.log(`💾 Cached ${videos.length} videos for channel ${channelName}`);
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn('localStorage full, caching without previews');
                    const cacheData = {
                        timestamp: Date.now(),
                        videos: videos.map(v => ({
                            name: v.name,
                            playlist: v.playlist || '',
                            views: v.views || 0,
                            likes: v.likes || 0,
                            created: v.created,
                            modified: v.modified,
                            tags: v.tags || [],
                            quality: v.quality || '',
                            duration: v.duration || 0
                        }))
                    };
                    try {
                        localStorage.setItem(`channelVideos_${channelName}`, JSON.stringify(cacheData));
                    } catch (e2) {
                        console.warn('Failed to cache channel videos:', e2);
                    }
                } else {
                    console.warn('Failed to cache channel videos:', e);
                }
            }
        }

        function loadChannelVideosCache(channelName) {
            try {
                const cached = localStorage.getItem(`channelVideos_${channelName}`);
                if (!cached) return null;
                
                const cacheData = JSON.parse(cached);
                const age = Date.now() - cacheData.timestamp;
                
                if (age > CHANNEL_VIDEOS_CACHE_TTL) {
                    if (CHANNEL_VIEW_DEBUG) console.log(`⏰ Channel videos cache expired (${Math.round(age/1000)}s old)`);
                    return null;
                }
                
                if (CHANNEL_VIEW_DEBUG) console.log(`✅ Using cached channel videos (${cacheData.videos.length} videos, ${Math.round(age/1000)}s old)`);
                return cacheData.videos;
            } catch (e) {
                console.warn('Failed to load channel videos cache:', e);
                return null;
            }
        }

        function invalidateChannelVideosCache(channelName) {
            try {
                localStorage.removeItem(`channelVideos_${channelName || currentChannelName}`);
                channelVideosLoaded = false;
                if (CHANNEL_VIEW_DEBUG) console.log(`🗑️ Invalidated channel videos cache for ${channelName || currentChannelName}`);
            } catch (e) {
                console.warn('Failed to invalidate cache:', e);
            }
        }

        async function forceRefreshChannelVideos() {
            invalidateChannelVideosCache(currentChannelName);
            channelVideos = [];
            channelVideosLoaded = false;
            await loadAllChannelVideos();
            await loadChannelVideos();
        }

 async function saveToDB(db, storeName, key, value) {
            try {
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
                
                if (db && db.objectStoreNames.contains(storeName)) {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.put(value, key);
                    if (CHANNEL_VIEW_DEBUG) console.log('Saved to IndexedDB successfully');
                } else {
                    if (CHANNEL_VIEW_DEBUG) console.warn(`IndexedDB store '${storeName}' does not exist, but data saved to localStorage`);
                }
            } catch (e) {
                console.error('Error saving to IndexedDB:', e);
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
            }
        }

  async function saveSubscriptionsToFile(subscriptions) {
            try {
                localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));
                
                if (videoDirectoryHandle) {
                    try {
                        const fileHandle = await videoDirectoryHandle.getFileHandle('.subscriptions.json', { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(subscriptions, null, 2));
                        await writable.close();
                    } catch (fileError) {
                        if (CHANNEL_VIEW_DEBUG) console.warn('Could not save to .subscriptions, but localStorage saved:', fileError);
                    }
                }

                window.dispatchEvent(new CustomEvent('subscriptionChanged'));
            } catch (e) {
                console.error('Error saving subscriptions:', e);
            }
        }

async function loadSubscriptionsFromFile() {
            try {
                const localSubscriptions = localStorage.getItem('8site_subscriptions');
                if (localSubscriptions && localSubscriptions !== 'null' && localSubscriptions !== 'undefined') {
                    const parsed = JSON.parse(localSubscriptions);
                    if (Array.isArray(parsed)) {
                        return parsed;
                    }
                }
                
                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
                        const file = await subscriptionsFile.getFile();
                        const text = await file.text();
                        const fileSubscriptions = JSON.parse(text);
                        
                        if (Array.isArray(fileSubscriptions)) {
                            localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
                            return fileSubscriptions;
                        }
                    } catch (fileError) {
                        if (CHANNEL_VIEW_DEBUG) console.log('Could not load from file:', fileError.message);
                    }
                }
                
                return [];
            } catch (e) {
                console.error('Error loading subscriptions:', e);
                return [];
            }
        }

        async function syncSubscriptions() {
            try {
                const db = await openDB();
                const fileSubscriptions = await loadSubscriptionsFromFile();
                const dbSubscriptions = await getFromDB(db, 'subscriptions');
                
                if (fileSubscriptions && !dbSubscriptions) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
                else if (dbSubscriptions && !fileSubscriptions) {
                    await saveSubscriptionsToFile(dbSubscriptions);
                }
                else if (fileSubscriptions && dbSubscriptions && 
                         JSON.stringify(fileSubscriptions) !== JSON.stringify(dbSubscriptions)) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
            } catch (e) {
                console.error('Error syncing subscriptions:', e);
            }
        }

        async function writeJSONFile(dirHandle, fileName, data) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();
            } catch (e) {
                console.error('Error writing file:', e);
            }
        }

        async function readJSONFile(dirHandle, fileName, defaultValue = null) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return defaultValue;
            }
        }

        async function saveImageFile(dirHandle, fileName, imageData) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(new Uint8Array(imageData));
                await writable.close();
                return fileName;
            } catch (e) {
                console.error('Error saving image:', e);
                return null;
            }
        }

        async function loadImageFile(dirHandle, fileName) {
            const cacheKey = `${dirHandle.name}_${fileName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
            }
            
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const url = URL.createObjectURL(file);
                
                avatarCache.set(cacheKey, {
                    url,
                    timestamp: Date.now()
                });
                
                return url;
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    console.error('Error loading image file:', e);
                }
                return null;
            }
        }

        async function getChannelDirectory() {
            const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
            return await channelsDir.getDirectoryHandle(currentChannelName, { create: true });
        }

        async function loadChannelData() {
            if (!currentChannelName) return;
            
            const startTime = performance.now();
            if (CHANNEL_VIEW_DEBUG) console.log('🚀 loadChannelData starting...');
            
            try {
                const channelDir = await getChannelDirectory();
                channelData = await readJSONFile(channelDir, 'channel.json', {
                    name: currentChannelName,
                    description: '',
                    avatar: null,
                    header: null,
                    background: null,
                    textColor: 'white',
                    theme: 'default',
                    feed: [],
                    playlists: [],
                    created: Date.now()
                });
                
                showVideoSkeletons();
                document.getElementById('channelName').textContent = currentChannelName;
                document.title = `${currentChannelName} | Youvi`;
                
                const channelTag = `${currentChannelName} (ка)`;
                const allDBVideos = await getAllVideosFromDB();
                
                if (allDBVideos && allDBVideos.length > 0) {
                    channelVideos = allDBVideos.filter(video => {
                        const tags = video.tags || [];
                        return tags.some(tag => tag === channelTag);
                    }).map(video => ({
                        name: video.name,
                        playlist: video.playlist || '',
                        views: video.views || 0,
                        likes: video.likes || 0,
                        dislikes: video.dislikes || 0,
                        created: video.created,
                        modified: video.modified,
                        tags: video.tags || [],
                        quality: video.quality || '',
                        duration: video.duration || 0,
                        preview: video.preview || null,
                        file: null,
                        handle: null,
                        dirHandle: null
                    }));
                    
                    if (channelVideos.length > 0) {
                        channelVideosLoaded = true;
                        if (CHANNEL_VIEW_DEBUG) console.log(`⚡ Loaded ${channelVideos.length} videos from IndexedDB in ${(performance.now() - startTime).toFixed(0)}ms`);
                        await renderChannel();
                        
                        attachFileHandlesInBackground();
                        return;
                    }
                }
                
                if (CHANNEL_VIEW_DEBUG) console.log('📂 No cache found, rendering UI first then scanning...');
                await renderChannel();
                
                setTimeout(async () => {
                    await loadAllChannelVideos();
                    if (channelVideos.length > 0) {
                        const sortType = document.getElementById('videoSortSelect')?.value || 'new';
                        const sortedVideos = sortVideos(channelVideos, sortType);
                        renderVideosGrid(sortedVideos);
                        await loadHomePage();
                    }
                }, 50);
                
                if (CHANNEL_VIEW_DEBUG) console.log(`✅ loadChannelData completed in ${(performance.now() - startTime).toFixed(0)}ms`);
            } catch (e) {
                console.error('Error loading channel data:', e);
            }
        }
        
        async function attachFileHandlesInBackground() {
            if (CHANNEL_VIEW_DEBUG) console.log('🔄 Starting background scan to attach file handles...');
            const scanStart = performance.now();
            const channelTag = `${currentChannelName} (ка)`;
            const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];
            const videoMap = new Map(channelVideos.map(v => [v.name, v]));
            let updatedCount = 0;
            
            async function scanDir(dir, playlist = '') {
                try {
                    const entries = [];
                    for await (const [name, handle] of dir.entries()) {
                        entries.push({ name, handle });
                    }
                    
                    for (const { name, handle } of entries) {
                        if (handle.kind === 'file') {
                            const isVideo = videoExtensions.some(ext => name.toLowerCase().endsWith(ext));
                            if (isVideo && videoMap.has(name)) {
                                try {
                                    const file = await handle.getFile();
                                    const video = videoMap.get(name);
                                    
                                    video.file = file;
                                    video.handle = handle;
                                    video.dirHandle = dir;
                                    video.playlist = playlist;
                                    
                                    try {
                                        const meta = await getVideoMetadata(dir, name);
                                        if (meta.duration && meta.duration !== '0:00') {
                                            video.duration = meta.duration;
                                        }
                                        if (meta.preview && !video.preview) {
                                            video.preview = meta.preview;
                                        }
                                        // Load views from metadata
                                        if (meta.views !== undefined) {
                                            video.views = meta.views;
                                        }
                                        if (meta.likes !== undefined) {
                                            video.likes = meta.likes;
                                        }
                                    } catch (e) { }
                                    
                                    updatedCount++;
                                } catch (e) { }
                            }
                        } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                            await scanDir(handle, name);
                        }
                    }
                } catch (e) { }
            }
            
            await scanDir(videoDirectoryHandle);
            
            if (CHANNEL_VIEW_DEBUG) console.log(`✅ Background scan completed in ${(performance.now() - scanStart).toFixed(0)}ms`);
            if (CHANNEL_VIEW_DEBUG) console.log(`📊 ${updatedCount}/${channelVideos.length} videos now have file handles`);
            
            if (updatedCount > 0) {
                const sortType = document.getElementById('videoSortSelect')?.value || 'new';
                const sortedVideos = sortVideos(channelVideos, sortType);
                renderVideosGrid(sortedVideos);
                await loadHomePage();
            }
        }

        async function loadAllVideosAndPlaylistsForAutocomplete() {
          if (typeof AutocompleteDataLoader === 'undefined') {
            console.error('[Autocomplete] AutocompleteDataLoader module not loaded');
            return { videos: [], playlists: [] };
          }
          
          const result = await AutocompleteDataLoader.loadData();
          return { videos: result.videos || [], playlists: result.playlists || [] };
        }

        async function saveChannelData() {
            if (!currentChannelName) return;
            
            try {
                const channelDir = await getChannelDirectory();
                await writeJSONFile(channelDir, 'channel.json', channelData);
            } catch (e) {
                console.error('Error saving channel data:', e);
            }
        }

        async function loadBirthdayData() {
            if (!currentChannelName || !videoDirectoryHandle) return null;
            
            try {
                const channelDir = await getChannelDirectory();
                return await readJSONFile(channelDir, 'birth.json', null);
            } catch (e) {
                return null;
            }
        }

        async function saveBirthdayData(birthdayData) {
            if (!currentChannelName || !videoDirectoryHandle) return;
            
            try {
                const channelDir = await getChannelDirectory();
                await writeJSONFile(channelDir, 'birth.json', birthdayData);
            } catch (e) {
                console.error('Error saving birthday data:', e);
            }
        }

        async function deleteBirthdayData() {
            if (!currentChannelName || !videoDirectoryHandle) return;
            
            try {
                const channelDir = await getChannelDirectory();
                await channelDir.removeEntry('birth.json');
            } catch (e) {
                if (CHANNEL_VIEW_DEBUG) console.log('Birthday file not found or error deleting:', e);
            }
        }

        function formatBirthdayDisplay(birthdayData) {
            if (!birthdayData || !birthdayData.day || !birthdayData.month) return '';
            
            const monthKeys = ['monthJan', 'monthFeb', 'monthMar', 'monthApr', 'monthMay', 'monthJun', 
                          'monthJul', 'monthAug', 'monthSep', 'monthOct', 'monthNov', 'monthDec'];
            
            const monthName = typeof i18n !== 'undefined' ? i18n.t(`channelView.${monthKeys[birthdayData.month - 1]}`) : 
                ['янв', 'фев', 'мар', 'апр', 'мая', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'][birthdayData.month - 1];
            
            let display = `${birthdayData.day} ${monthName}`;
            
            if (birthdayData.year) {
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth() + 1;
                const currentDay = now.getDate();
                
                let age = currentYear - birthdayData.year;
                if (currentMonth < birthdayData.month || 
                    (currentMonth === birthdayData.month && currentDay < birthdayData.day)) {
                    age--;
                }
                
                display += ` ${birthdayData.year} (${age} ${getAgeWord(age)})`;
            }
            
            return display;
        }

        function getAgeWord(age) {
            if (typeof i18n !== 'undefined') {
                const lastDigit = age % 10;
                const lastTwoDigits = age % 100;
                
                if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                    return i18n.t('channelView.yearsOld');
                }
                if (lastDigit === 1) {
                    return i18n.t('channelView.yearOld');
                }
                if (lastDigit >= 2 && lastDigit <= 4) {
                    return i18n.t('channelView.yearsOld2');
                }
                return i18n.t('channelView.yearsOld');
            }
            
            const lastDigit = age % 10;
            const lastTwoDigits = age % 100;
            
            if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                return 'лет';
            }
            
            if (lastDigit === 1) {
                return 'год';
            }
            
            if (lastDigit >= 2 && lastDigit <= 4) {
                return 'года';
            }
            
            return 'лет';
        }

        function getViewsWord(count) {
            if (typeof i18n !== 'undefined') {
                const lastDigit = count % 10;
                const lastTwoDigits = count % 100;
                
                if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                    return i18n.t('channelView.views');
                }
                if (lastDigit === 1) {
                    return i18n.t('channelView.view');
                }
                if (lastDigit >= 2 && lastDigit <= 4) {
                    return i18n.t('channelView.viewsPlural2');
                }
                return i18n.t('channelView.views');
            }
            
            const lastDigit = count % 10;
            const lastTwoDigits = count % 100;
            
            if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                return 'просмотров';
            }
            
            if (lastDigit === 1) {
                return 'просмотр';
            }
            
            if (lastDigit >= 2 && lastDigit <= 4) {
                return 'просмотра';
            }
            
            return 'просмотров';
        }

        function getVideoWord(count) {
            if (typeof i18n !== 'undefined') {
                return i18n.t('channelView.videos');
            }
            return 'видео';
        }

        async function updateChannelStats(videoCount, viewCount) {
            const statsEl = document.getElementById('channelStats');
            if (!statsEl) return;
            
            let statsText = `${videoCount} ${getVideoWord(videoCount)} • ${viewCount} ${getViewsWord(viewCount)}`;
            
            const birthdayData = await loadBirthdayData();
            if (birthdayData && birthdayData.day && birthdayData.month) {
                const birthdayDisplay = formatBirthdayDisplay(birthdayData);
                statsText += ` • ${birthdayDisplay}`;
            }
            
            statsEl.textContent = statsText;
        }

        async function renderChannel() {
            const startTime = performance.now();
            if (CHANNEL_VIEW_DEBUG) console.log('🎨 Rendering channel...');
            
            document.getElementById('channelName').textContent = currentChannelName;
            document.title = `${currentChannelName} | Youvi`;
            
            const nameEl = document.getElementById('channelName');
            nameEl.className = `channel-name ${channelData.textColor === 'black' ? 'dark-text' : ''}`;
            
            const avatarEl = document.getElementById('channelAvatar');
            avatarEl.textContent = currentChannelName.charAt(0).toUpperCase();
            
            if (channelVideosLoaded && channelVideos.length > 0) {
                const sortType = document.getElementById('videoSortSelect')?.value || 'new';
                const sortedVideos = sortVideos(channelVideos, sortType);
                renderVideosGrid(sortedVideos);
                
                const totalViews = channelVideos.reduce((sum, v) => sum + (v.views || 0), 0);
                updateChannelStats(channelVideos.length, totalViews);
            } else {
                showVideoSkeletons();
            }
            
            const parallelTasks = [
                loadDescriptionAndTags(),
                loadPlaylists(),
                loadChannelImages(),
                loadHomePage(),
            ];
            
            Promise.all(parallelTasks).catch(e => console.warn('Parallel task error:', e));
            
            loadPinnedVideo().catch(e => console.warn('Pinned video error:', e));
            
            setTimeout(() => initializeAnalytics(), 100);
            
            if (CHANNEL_VIEW_DEBUG) console.log(`✅ Channel rendered in ${(performance.now() - startTime).toFixed(0)}ms`);
        }
        
        function showVideoSkeletons() {
            const grids = ['recentVideosGrid', 'recentVideosGrid2', 'videosGrid'];
            grids.forEach(gridId => {
                const grid = document.getElementById(gridId);
                if (!grid) return;
                
                const count = gridId === 'videosGrid' ? 12 : 5;
                grid.innerHTML = Array(count).fill(0).map(() => `
                    <div class="video-item skeleton-item">
                        <div class="video-thumb skeleton-thumb"></div>
                        <div class="video-info">
                            <div class="skeleton-line" style="height:13px;width:90%;margin-bottom:4px;"></div>
                            <div class="skeleton-line" style="height:11px;width:60%;"></div>
                        </div>
                    </div>
                `).join('');
            });
        }
        
        async function loadChannelImages() {
            const avatarEl = document.getElementById('channelAvatar');
            const headerEl = document.getElementById('channelHeader');
            
            try {
                const channelDir = await getChannelDirectory();
                
                const imagePromises = [];
                
                if (channelData?.avatar) {
                    imagePromises.push(
                        loadImageFile(channelDir, channelData.avatar).then(url => {
                            if (url) {
                                avatarEl.style.backgroundImage = `url(${url})`;
                                avatarEl.classList.add('custom-avatar');
                                avatarEl.textContent = '';
                                
                                const authorAvatarEl = document.getElementById('authorAvatar');
                                if (authorAvatarEl) {
                                    authorAvatarEl.style.backgroundImage = `url(${url})`;
                                    authorAvatarEl.style.backgroundSize = 'cover';
                                    authorAvatarEl.style.backgroundPosition = 'center';
                                    authorAvatarEl.textContent = '';
                                }
                            }
                        }).catch(() => {})
                    );
                }
                
                if (channelData?.header) {
                    imagePromises.push(
                        loadImageFile(channelDir, channelData.header).then(url => {
                            if (url) {
                                headerEl.style.backgroundImage = `url(${url})`;
                                headerEl.classList.add('custom-bg');
                            }
                        }).catch(() => {})
                    );
                }
                
                if (channelData?.background) {
                    imagePromises.push(
                        loadImageFile(channelDir, channelData.background).then(url => {
                            if (url) {
                                document.body.style.setProperty('--bg-image', `url(${url})`);
                                document.body.classList.add('custom-background');
                            }
                        }).catch(() => {})
                    );
                } else {
                    document.body.classList.remove('custom-background');
                    document.body.style.removeProperty('--bg-image');
                }
                
                await Promise.all(imagePromises);
            } catch (e) {
                console.warn('Error loading channel images:', e);
            }
        }

        async function initializeAnalytics() {
            if (!channelAnalyticsInstance) {
                channelAnalyticsInstance = new OptimizedChannelAnalytics(currentChannelName);
            }
            
            if (!channelAchievementsInstance) {
                channelAchievementsInstance = new ChannelAchievements();
            }
            
            loadShownAchievements();
            
            taskQueue.add(async () => {
                const analytics = await channelAnalyticsInstance.updateAnalytics(channelVideos);
                channelAnalyticsInstance.renderAnalytics();
                
                const newAchievements = channelAchievementsInstance.checkAchievements(analytics);
                channelAchievementsInstance.renderAchievements();
                
                if (newAchievements.length > 0) {
                    showAchievementNotification(newAchievements);
                }
                
                return analytics;
            }, 1);
        }

        const shownAchievements = new Set();
        
        function loadShownAchievements() {
            try {
                const saved = localStorage.getItem(`achievements_${currentChannelName}`);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    parsed.forEach(id => shownAchievements.add(id));
                }
            } catch (e) {
                console.error('Error loading achievements:', e);
            }
        }
        
        function saveShownAchievements() {
            try {
                const achievementsArray = Array.from(shownAchievements);
                localStorage.setItem(`achievements_${currentChannelName}`, JSON.stringify(achievementsArray));
            } catch (e) {
                console.error('Error saving achievements:', e);
            }
        }

        function showAchievementNotification(achievements) {
            achievements.forEach(achievement => {
                if (shownAchievements.has(achievement.id)) {
                    return;
                }
                
                shownAchievements.add(achievement.id);
                saveShownAchievements();
                
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 15px;
                    right: 15px;
                    background: linear-gradient(135deg, #d94b88, #ff69b4);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 6px;
                    box-shadow: 0 3px 8px rgba(217, 75, 136, 0.3);
                    z-index: 10001;
                    animation: slideIn 0.3s ease-out;
                    max-width: 250px;
                    font-size: 12px;
                `;
                
                notification.innerHTML = `
                    <div style="display:flex;align-items:center;gap:8px;">
                        <div style="width:20px;height:20px;display:flex;align-items:center;justify-content:center;">
                            ${achievement.icon.replace('stroke="#d94b88"', 'stroke="white"').replace('width="24" height="24"', 'width="20" height="20"')}
                        </div>
                        <div>
                            <div style="font-weight:600;margin-bottom:1px;font-size:11px;">${typeof i18n !== 'undefined' ? i18n.t('channelView.achievements') : 'Достижение'}!</div>
                            <div style="font-size:10px;opacity:0.9;">${channelAchievementsInstance ? channelAchievementsInstance.getTitle(achievement) : achievement.titleKey}</div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }, 2500);
            });
        }
async function loadAllChannelVideos() {
    const startTime = performance.now();
    if (CHANNEL_VIEW_DEBUG) console.log('🚀 Loading channel videos (optimized)...');
    
    const cachedVideos = loadChannelVideosCache(currentChannelName);
    if (cachedVideos && cachedVideos.length > 0) {
        channelVideos = cachedVideos;
        channelVideosLoaded = true;
        if (CHANNEL_VIEW_DEBUG) console.log(`⚡ Loaded ${channelVideos.length} videos from cache in ${(performance.now() - startTime).toFixed(0)}ms`);
        return;
    }
    
    const channelTag = `${currentChannelName} (ка)`;
    try {
        const allDBVideos = await getAllVideosFromDB();
        if (allDBVideos && allDBVideos.length > 0) {
            if (CHANNEL_VIEW_DEBUG) console.log(`📦 Found ${allDBVideos.length} videos in IndexedDB, filtering by channel tag...`);
            
            channelVideos = allDBVideos.filter(video => {
                const tags = video.tags || [];
                return tags.some(tag => tag === channelTag);
            }).map(video => ({
                name: video.name,
                playlist: video.playlist || '',
                views: video.views || 0,
                likes: video.likes || 0,
                dislikes: video.dislikes || 0,
                created: video.created,
                modified: video.modified,
                tags: video.tags || [],
                quality: video.quality || '',
                duration: video.duration || 0,
                preview: video.preview || null,
                dirHandle: video.dirHandle || null
            }));
            
            if (channelVideos.length > 0) {
                channelVideosLoaded = true;
                saveChannelVideosCache(currentChannelName, channelVideos);
                if (CHANNEL_VIEW_DEBUG) console.log(`⚡ Loaded ${channelVideos.length} channel videos from IndexedDB in ${(performance.now() - startTime).toFixed(0)}ms`);
                return;
            }
        }
    } catch (e) {
        console.warn('IndexedDB lookup failed, falling back to filesystem scan:', e);
    }
    
    if (CHANNEL_VIEW_DEBUG) console.log('📂 No cache found, scanning filesystem...');
    channelVideos = [];
    const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];
    
    async function collectEntries(dirHandle, playlistName = '', entries = []) {
        try {
            const items = [];
            for await (const [name, handle] of dirHandle.entries()) {
                items.push([name, handle, playlistName]);
            }
            
            for (const [name, handle, playlist] of items) {
                if (handle.kind === 'file') {
                    const isVideo = videoExtensions.some(ext => name.toLowerCase().endsWith(ext));
                    if (isVideo) {
                        entries.push([name, handle, dirHandle, playlist]);
                    }
                } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                    await collectEntries(handle, name, entries);
                }
            }
        } catch (e) {
        }
        return entries;
    }
    
    const allEntries = await collectEntries(videoDirectoryHandle);
    if (CHANNEL_VIEW_DEBUG) console.log(`Found ${allEntries.length} videos, filtering by channel tag...`);
    
    let processed = 0;
    
    for (let i = 0; i < allEntries.length; i += BATCH_SIZE) {
        const batch = allEntries.slice(i, i + BATCH_SIZE);
        
        await Promise.all(
            batch.map(async ([name, handle, dirHandle, playlistName]) => {
                try {
                    const metadata = await getVideoMetadata(dirHandle, name);
                    const hasChannelTag = (metadata.tags || []).some(tag => tag === channelTag);
                    
                    if (hasChannelTag) {
                        channelVideos.push({
                            name,
                            handle,
                            directoryHandle: dirHandle,
                            playlist: playlistName,
                            ...metadata
                        });
                    }
                    processed++;
                } catch (e) {
                }
            })
        );
        
        if (i % 100 === 0 && i > 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
    
    channelVideosLoaded = true;
    saveChannelVideosCache(currentChannelName, channelVideos);
    if (CHANNEL_VIEW_DEBUG) console.log(`✅ Loaded ${channelVideos.length} channel videos via filesystem in ${(performance.now() - startTime).toFixed(0)}ms`);
}

async function getVideoMetadata(dirHandle, fileName) {
    const cacheKey = `${dirHandle.name}_${fileName}`;
    if (metadataCache.has(cacheKey)) {
        const cached = metadataCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 30000) {
            return cached.data;
        }
    }
    
    try {
        const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
        const metaFileName = fileName + '.meta.json';
        const fileHandle = await metaDir.getFileHandle(metaFileName);
        const file = await fileHandle.getFile();
        const text = await file.text();
        const data = JSON.parse(text);
        
        metadataCache.set(cacheKey, {
            data,
            timestamp: Date.now()
        });
        
        return data;
    } catch (e) {
        const defaultData = {
            views: 0,
            likes: 0,
            dislikes: 0,
            tags: [],
            created: Date.now()
        };
        
        metadataCache.set(cacheKey, {
            data: defaultData,
            timestamp: Date.now()
        });
        
        return defaultData;
    }
}

async function loadChannelVideos() {
    const startTime = performance.now();
    
    try {
        if (channelVideosLoaded && channelVideos.length > 0) {
            if (CHANNEL_VIEW_DEBUG) console.log(`⚡ Using ${channelVideos.length} cached channel videos`);
        } else {
            await loadAllChannelVideos();
        }
        
        const totalViews = channelVideos.reduce((sum, v) => sum + (v.views || 0), 0);
        updateChannelStats(channelVideos.length, totalViews);

        const sortType = document.getElementById('videoSortSelect')?.value || 'new';
        const sortedVideos = sortVideos(channelVideos, sortType);
        renderVideosGrid(sortedVideos);
        
        if (CHANNEL_VIEW_DEBUG) console.log(`✅ loadChannelVideos completed in ${(performance.now() - startTime).toFixed(0)}ms`);
    } catch (e) {
        console.error('Error loading channel videos:', e);
        const grid = document.getElementById('videosGrid');
        if (grid) {
            grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:#d94b88;padding:40px">Ошибка загрузки видео</div>';
        }
    }
}
        function renderVideos(sortedVideos) {
            renderVideosGrid(sortedVideos);
        }

        function renderVideosGrid(sortedVideos) {
                const grid = document.getElementById('videosGrid');
            if (!grid) return;
            
                grid.innerHTML = '';

                if (sortedVideos.length === 0) {
                    const noVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.noVideosYet') : 'На канале пока нет видео';
                    grid.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#7a3c55;padding:40px">${noVideosText}</div>`;
                    return;
                }

            const maxPlaceholders = Math.min(VISIBLE_ITEMS, sortedVideos.length);
            const placeholders = sortedVideos.slice(0, maxPlaceholders).map(() => {
                const item = document.createElement('div');
                item.className = 'video-item loading-placeholder';
                item.style.height = '200px';
                return item;
            });
            
            placeholders.forEach(placeholder => grid.appendChild(placeholder));

            sortedVideos.forEach((video, index) => {
                    const item = document.createElement('div');
                    item.className = 'video-item';
                    item.setAttribute('data-video-name', video.name);
                    
                    const playlist = video.playlist || '';
                    const videoUrl = window.VideoID 
                        ? window.VideoID.buildVideoUrl(video.name, playlist)
                        : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist)}`;
                    
                    const hiddenLink = document.createElement('a');
                    hiddenLink.href = videoUrl;
                    hiddenLink.target = '_blank';
                    hiddenLink.className = 'video-item-link';
                    item.appendChild(hiddenLink);
                    
                    const thumb = document.createElement('div');
                    thumb.className = 'video-thumb';
                    thumb.style.position = 'relative';
                    
                    const pinElement = document.createElement('button');
                    pinElement.className = 'video-pin-hover action-btn';
                    pinElement.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>';
                    const isPinned = channelData.pinnedVideo === video.name;
                    pinElement.title = isPinned ? 'Открепить видео' : 'Закрепить видео';
                    pinElement.setAttribute('data-pinned', isPinned);
                    pinElement.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        width: 28px;
                        height: 28px;
                        background: rgba(0,0,0,0.7);
                        border: none;
                        border-radius: 4px;
                        color: #fff;
                        font-size: 12px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        opacity: 0;
                        transition: opacity 0.2s;
                        z-index: 1000;
                        pointer-events: auto;
                    `;
                    
                    item.addEventListener('mouseenter', () => {
                        pinElement.style.opacity = '1';
                    });
                    item.addEventListener('mouseleave', () => {
                        pinElement.style.opacity = '0';
                    });
                    
                    pinElement.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleVideoPin(video);
                    });
                    
                    item.appendChild(pinElement);
                    
                    thumb.addEventListener('click', () => {
                        window.location.href = videoUrl;
                    });
                    
                    const info = document.createElement('div');
                    info.className = 'video-info';
                    const displayName = getFileNameWithoutExtension(video.name);
                    const views = video.views || 0;
                    const danmakuCount = video.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(video.name) : 0);
                    const createdDateObj = video.created ? new Date(video.created) : (video.modified ? new Date(video.modified) : null);
                    const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
                    const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
                    const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
                    const dateLine = dateStr ? `<div class="video-date" style="color:#888;font-size:12px;">${dateStr}</div>` : '';
                    const statsLine = `<div class="video-stats" style="color:#888;font-size:12px;">${viewsSvg} ${views.toLocaleString()} • ${danmakuSvg} ${danmakuCount}</div>`;
                    info.innerHTML = `
                        <div class="video-title">${displayName}</div>
                        ${dateLine}
                        ${statsLine}
                    `;
                    
                    item.appendChild(thumb);
                    item.appendChild(info);
                
                if (index < maxPlaceholders) {
                    grid.replaceChild(item, placeholders[index]);
                } else {
                    grid.appendChild(item);
                }
                
                const priority = index < 10 ? 2 : index < 20 ? 1 : 0;
                lazyLoader.addVideo(video, thumb, priority);
            });
        }

        async function loadDescriptionAndTags() {
            const descText = document.getElementById('descriptionText');
            if (descText) {
                if (channelData.description) {
                    if (channelData.descriptionTitle) {
                        descText.innerHTML = `<h4 style="margin:0 0 10px 0;color:#333;font-size:16px;">${escapeHtml(channelData.descriptionTitle)}</h4>${channelData.description}`;
                    } else {
                        descText.innerHTML = channelData.description;
                    }
                } else {
                    const noDescText = typeof i18n !== 'undefined' ? i18n.t('channelView.noDescription') : 'Описание не задано';
                    const noDescHint = typeof i18n !== 'undefined' ? i18n.t('channelView.noDescriptionHint') : 'Нажмите "Редактировать" чтобы добавить описание канала';
                    descText.innerHTML = `<div style="text-align:center;color:#999;padding:40px 20px"><div style="font-size:16px;margin-bottom:10px">${noDescText}</div><div style="font-size:13px;color:#666">${noDescHint}</div></div>`;
                }
            }
            
            loadSidebarTags();
        }

        function loadSidebarTags() {
            const sidebarTagsContainer = document.getElementById('sidebarTagsContainer');
            if (!sidebarTagsContainer) return;
            
            const tagTypeColors = {
              'gt': '#6b7280',
              'au': '#ef6c7d',
              'st': '#f28b8b',
              'yr': '#eab676',
              'at': '#a78bdb',
              'ser': '#8db8d6',
              'mt': '#d4a373',
              'nat': '#9dd6a8',
              'ra': '#f5a3c7',
              'ge': '#6b9bd1',
              'tp': '#f59e6c',
              'ch': '#6b9e4d',
              'ct': '#67c5d6'
            };

            function parseTagType(tagString) {
              if (!tagString) return null;
              const match = tagString.trim().match(/\(([a-zа-я]{2,3})\)$/iu);
              return match ? match[1].toLowerCase() : null;
            }

            function parseTagContent(tagString) {
              if (!tagString) return tagString;
              const match = tagString.trim().match(/^(.+?)\s*\([a-zа-я]{2,3}\)$/iu);
              return match ? match[1].trim() : tagString;
            }
            
            const allTags = new Map();
            
            channelVideos.forEach(video => {
                if (video.tags) {
                    video.tags.forEach(tag => {
                        const typeCode = parseTagType(tag);
                        if (typeCode && typeCode !== 'ка' && typeCode !== 'ct') {
                            allTags.set(tag, (allTags.get(tag) || 0) + 1);
                        }
                    });
                }
            });
            
            const sortedTags = Array.from(allTags.entries())
                .sort((a, b) => b[1] - a[1]);
            
            sidebarTagsContainer.innerHTML = '';
            sortedTags.forEach(([tag, count]) => {
                const tagItem = document.createElement('a');
                tagItem.href = '#';
                tagItem.className = 'sidebar-item';
                tagItem.style.display = 'flex';
                tagItem.style.justifyContent = 'space-between';
                tagItem.style.alignItems = 'center';
                
                const typeCode = parseTagType(tag);
                const color = typeCode ? tagTypeColors[typeCode] : '#666';
                
                const content = parseTagContent(tag);
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = content;
                nameSpan.style.color = color;
                
                const countSpan = document.createElement('span');
                countSpan.textContent = count;
                countSpan.style.color = '#999';
                countSpan.style.marginLeft = '8px';
                countSpan.style.marginRight = '12px';
                countSpan.style.flexShrink = '0';
                
                tagItem.appendChild(nameSpan);
                tagItem.appendChild(countSpan);
                tagItem.dataset.tag = tag;
                
                tagItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    filterVideosByTag(tag);
                });
                sidebarTagsContainer.appendChild(tagItem);
            });
        }

        function filterVideosByTag(tag) {
            document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            document.getElementById('allTagsLink').classList.remove('active');
            
            const clickedTagItem = document.querySelector(`[data-tag="${tag}"]`);
            if (clickedTagItem) {
                clickedTagItem.classList.add('active');
            }
            
            const filteredVideos = channelVideos.filter(video => 
                video.tags && video.tags.includes(tag)
            );
            
            renderVideos(filteredVideos);
        }

        async function loadPlaylists() {
            const playlistsGrid = document.getElementById('playlistsGrid');
            if (!playlistsGrid) return;
            playlistsGrid.innerHTML = '';

            if (!channelData.playlists || channelData.playlists.length === 0) {
                const noPlaylistsText = typeof i18n !== 'undefined' ? i18n.t('channelView.noPlaylistsYet') : 'Плейлистов пока нет';
                playlistsGrid.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#7a3c55;padding:40px">${noPlaylistsText}</div>`;
                return;
            }

             const sortType = getCurrentSortType();
            const sortedPlaylists = sortPlaylists(channelData.playlists, sortType);

            sortedPlaylists.forEach(playlist => {
                if (playlist.videos && channelVideos.length > 0) {
                    playlist.videos = playlist.videos.map(video => {
                        const foundVideo = channelVideos.find(cv => cv.name === video.name);
                        if (foundVideo) {
                            return {
                                ...video,
                                handle: foundVideo.handle,
                                file: foundVideo.file,
                                dirHandle: foundVideo.dirHandle
                            };
                        }
                        return video;
                    });
                }

                const item = document.createElement('div');
                item.className = 'playlist-item';
                
                const playlistUrl = `youvi_playlists_view.html?playlistId=${encodeURIComponent(playlist.id)}`;
                
                const hiddenLink = document.createElement('a');
                hiddenLink.href = playlistUrl;
                hiddenLink.target = '_blank';
                hiddenLink.className = 'playlist-item-link';
                item.appendChild(hiddenLink);

                const thumbGrid = document.createElement('div');
                thumbGrid.className = 'playlist-thumbnail';

                for (let i = 0; i < 4; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'playlist-thumb';
                    if (playlist.videos && playlist.videos[i]) {
                        const v = playlist.videos[i];
                        cell.textContent = getFileNameWithoutExtension(v.name).slice(0, 10) + '…';

                        const foundVideo = channelVideos.find(av => av.name === v.name);
                        if (foundVideo) {
                            getPreviewAndDuration(foundVideo).then(({preview}) => {
                                if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                                    cell.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';">`;
                                }
                            }).catch(() => {  });
                        }
                    }
                    thumbGrid.appendChild(cell);
                }

                const countBadge = document.createElement('div');
                countBadge.className = 'playlist-count-badge';
                countBadge.textContent = `${(playlist.videos || []).length} ${typeof i18n !== 'undefined' ? i18n.t('channelView.videos') : 'видео'}`;
                thumbGrid.appendChild(countBadge);

                const info = document.createElement('div');
                info.className = 'playlist-info';
                const untitledText = typeof i18n !== 'undefined' ? i18n.t('channelView.untitled') : 'Без названия';
                const openPlaylistText = typeof i18n !== 'undefined' ? i18n.t('channelView.openPlaylist') : 'Открыть плейлист';
                info.innerHTML = `
                    <div class="playlist-channel">${currentChannelName}</div>
                    <div class="playlist-title">${escapeHtml(playlist.title || untitledText)}</div>
                    <div class="playlist-open" style="font-size:12px;color:#666;">${openPlaylistText}</div>
                `;

                const actions = document.createElement('div');
                actions.className = 'playlist-actions';
                actions.style.cssText = 'position:absolute;top:8px;right:8px;display:flex;gap:4px;opacity:0;transition:opacity .2s;z-index:10';

                const editBtn = document.createElement('button');
                editBtn.className = 'playlist-edit-btn';
                editBtn.style.cssText = 'width:28px;height:28px;background:rgba(0,0,0,0.7);border:none;border-radius:4px;color:#fff;font-size:12px;cursor:pointer;display:flex;align-items:center;justify-content:center';
                editBtn.title = typeof i18n !== 'undefined' ? i18n.t('channelView.edit') : 'Редактировать';
                editBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg>';
                editBtn.onclick = (e) => { e.stopPropagation(); editPlaylist(playlist); };

                const delBtn = document.createElement('button');
                delBtn.className = 'playlist-delete-btn';
                delBtn.style.cssText = 'width:28px;height:28px;background:rgba(0,0,0,0.7);border:none;border-radius:4px;color:#fff;font-size:12px;cursor:pointer;display:flex;align-items:center;justify-content:center';
                delBtn.title = typeof i18n !== 'undefined' ? i18n.t('channelView.delete') : 'Удалить';
                delBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
                delBtn.onclick = (e) => { e.stopPropagation(); deletePlaylist(playlist); };

                actions.appendChild(editBtn);
                actions.appendChild(delBtn);

                item.appendChild(thumbGrid);
                item.appendChild(info);
                item.appendChild(actions);

                item.addEventListener('mouseenter', () => actions.style.opacity = '1');
                item.addEventListener('mouseleave', () => actions.style.opacity = '0');

                item.addEventListener('click', () => {
                    openPlaylist(playlist.id);
                });

                playlistsGrid.appendChild(item);
            });
        }

        function openPlaylist(playlistId) {
            window.location.href = `youvi_playlists_view.html?playlistId=${encodeURIComponent(playlistId)}`;
        }

        async function loadHomePage() {
            await Promise.all([
                loadRecentVideos(),
                loadRecentVideos2(),
                loadRecentPlaylists(),
                loadTopVideos()
            ]);
            
            // Fix background after loading
            fixTopVideosBackground();
        }

        function renderVideoCard(video, container) {
            console.log('renderVideoCard video:', video.name, 'views:', video.views);
            const item = document.createElement('div');
            item.className = 'video-item';
            
            const playlist = video.playlist || '';
            const videoUrl = window.VideoID 
                ? window.VideoID.buildVideoUrl(video.name, playlist)
                : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist)}`;
            
            const hiddenLink = document.createElement('a');
            hiddenLink.href = videoUrl;
            hiddenLink.target = '_blank';
            hiddenLink.className = 'video-item-link';
            item.appendChild(hiddenLink);
            
            const thumb = document.createElement('div');
            thumb.className = 'video-thumb';
            thumb.style.position = 'relative';
            
            const displayName = getFileNameWithoutExtension(video.name);
            thumb.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:10px;text-align:center;padding:5px;">${displayName}</div>`;
            
            const durationBadge = document.createElement('div');
            durationBadge.className = 'video-duration';
            durationBadge.textContent = video.duration ? formatDuration(video.duration) : '--:--';
            thumb.appendChild(durationBadge);
            
            if (video.quality) {
                const qualityBadge = document.createElement('div');
                qualityBadge.className = 'video-quality';
                qualityBadge.textContent = video.quality;
                thumb.appendChild(qualityBadge);
            }
            
            if (video.created && (Date.now() - video.created) < 24 * 60 * 60 * 1000) {
                const newBadge = document.createElement('div');
                newBadge.className = 'video-new';
                newBadge.textContent = 'Новинка';
                thumb.appendChild(newBadge);
            }
            
            thumb.addEventListener('click', () => window.location.href = videoUrl);
            
            const info = document.createElement('div');
            info.className = 'video-info';
            const danmakuCount = video.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(video.name) : 0);
            const createdDateObj = video.created ? new Date(video.created) : (video.modified ? new Date(video.modified) : null);
            const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
            const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
            const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
            const dateLine = dateStr ? `<div class="video-date" style="color:#888;font-size:12px;">${dateStr}</div>` : '';
            const statsLine = `<div class="video-stats" style="color:#888;font-size:12px;">${viewsSvg} ${(video.views || 0).toLocaleString()} • ${danmakuSvg} ${danmakuCount}</div>`;
            info.innerHTML = `
                <div class="video-title">${displayName}</div>
                ${dateLine}
                ${statsLine}
            `;
            
            item.appendChild(thumb);
            item.appendChild(info);
            container.appendChild(item);
            
            getPreviewAndDuration(video).then(({ preview, duration }) => {
                if (preview && preview.length > 50 && !preview.includes('blob:null/')) {
                    const img = document.createElement('img');
                    img.src = preview;
                    img.style.cssText = 'width:100%;height:100%;object-fit:cover;';
                    img.onerror = () => img.style.display = 'none';
                    thumb.innerHTML = '';
                    thumb.appendChild(img);
                }
                
                const dur = document.createElement('div');
                dur.className = 'video-duration';
                dur.textContent = duration || '--:--';
                thumb.appendChild(dur);
                
                if (video.quality) {
                    const qb = document.createElement('div');
                    qb.className = 'video-quality';
                    qb.textContent = video.quality;
                    thumb.appendChild(qb);
                }
                
                if (video.created && (Date.now() - video.created) < 24 * 60 * 60 * 1000) {
                    const nb = document.createElement('div');
                    nb.className = 'video-new';
                    nb.textContent = 'Новинка';
                    thumb.appendChild(nb);
                }
            }).catch(() => {});
            
            return item;
        }

        async function loadRecentVideos() {
            const recentGrid = document.getElementById('recentVideosGrid');
            if (!recentGrid) return;
            
            recentGrid.innerHTML = '';
            
            if (channelVideos.length === 0) {
                const noVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.noVideosYet') : 'На канале пока нет видео';
                recentGrid.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#7a3c55;padding:40px">${noVideosText}</div>`;
                return;
            }

            const sortType = document.getElementById('videoSortSelect')?.value || 'new';
            const sortedVideos = sortVideos(channelVideos, sortType);
            const recentVideos = sortedVideos.slice(0, 5);
            
            recentVideos.forEach(video => renderVideoCard(video, recentGrid));
        }

        async function loadRecentVideos2() {
            const recentGrid = document.getElementById('recentVideosGrid2');
            if (!recentGrid) return;
            
            recentGrid.innerHTML = '';
            
            if (channelVideos.length <= 5) {
                const noMoreVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.noMoreVideos') : 'Больше видео нет';
                recentGrid.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#7a3c55;padding:40px">${noMoreVideosText}</div>`;
                return;
            }

            const sortType = document.getElementById('videoSortSelect')?.value || 'new';
            const sortedVideos = sortVideos(channelVideos, sortType);
            const recentVideos = sortedVideos.slice(5, 10);
            
            recentVideos.forEach(video => renderVideoCard(video, recentGrid));
        }

        async function loadRecentPlaylists() {
            const recentPlaylistsGrid = document.getElementById('recentPlaylistsGrid');
            if (!recentPlaylistsGrid) return;
            
            recentPlaylistsGrid.innerHTML = '';
            
            if (!channelData.playlists || channelData.playlists.length === 0) {
                const noPlaylistsText = typeof i18n !== 'undefined' ? i18n.t('channelView.noPlaylistsYet') : 'Плейлистов пока нет';
                recentPlaylistsGrid.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#7a3c55;padding:40px">${noPlaylistsText}</div>`;
                return;
            }
            
             const sortType = getCurrentSortType();
            const sortedPlaylists = sortPlaylists(channelData.playlists, sortType);
            const recentPlaylists = sortedPlaylists.slice(0, 5);
            
            recentPlaylists.forEach(playlist => {
                const item = document.createElement('div');
                item.className = 'playlist-item';
                
                const playlistUrl = `youvi_playlists_view.html?playlistId=${encodeURIComponent(playlist.id)}`;
                
                const hiddenLink = document.createElement('a');
                hiddenLink.href = playlistUrl;
                hiddenLink.target = '_blank';
                hiddenLink.className = 'playlist-item-link';
                item.appendChild(hiddenLink);

                const thumbGrid = document.createElement('div');
                thumbGrid.className = 'playlist-thumbnail';

                for (let i = 0; i < 4; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'playlist-thumb';
                    if (playlist.videos && playlist.videos[i]) {
                        const v = playlist.videos[i];
                        cell.textContent = getFileNameWithoutExtension(v.name).slice(0, 10) + '…';
                        
                        const foundVideo = channelVideos.find(av => av.name === v.name);
                        if (foundVideo) {
                            getPreviewAndDuration(foundVideo).then(({preview}) => {
                                if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                                    cell.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';">`;
                                }
                            }).catch(() => {  });
                        }
                    }
                    thumbGrid.appendChild(cell);
                }

                const countBadge = document.createElement('div');
                countBadge.className = 'playlist-count-badge';
                countBadge.textContent = `${(playlist.videos || []).length} ${typeof i18n !== 'undefined' ? i18n.t('channelView.videos') : 'видео'}`;
                thumbGrid.appendChild(countBadge);

                const info = document.createElement('div');
                info.className = 'playlist-info';
                const untitledText = typeof i18n !== 'undefined' ? i18n.t('channelView.untitled') : 'Без названия';
                const openPlaylistText = typeof i18n !== 'undefined' ? i18n.t('channelView.openPlaylist') : 'Открыть плейлист';
                info.innerHTML = `
                    <div class="playlist-channel">${currentChannelName}</div>
                    <div class="playlist-title">${escapeHtml(playlist.title || untitledText)}</div>
                    <div class="playlist-open" style="font-size:12px;color:#666;">${openPlaylistText}</div>
                `;

                item.appendChild(thumbGrid);
                item.appendChild(info);
                
                item.addEventListener('click', () => {
                    openPlaylist(playlist.id);
                });
                
                recentPlaylistsGrid.appendChild(item);
            });
        }

        async function loadTopVideos() {
            const topVideosList = document.getElementById('topVideosList');
            if (!topVideosList) return;
            
            topVideosList.innerHTML = '';
            
            if (channelVideos.length === 0) {
                topVideosList.innerHTML = '<div style="text-align:center;color:#7a3c55;padding:20px;font-size:12px">Нет видео</div>';
                return;
            }
            
            const sortedVideos = [...channelVideos].sort((a, b) => (b.views || 0) - (a.views || 0));
            const topVideos = sortedVideos.slice(0, 5);
            
            topVideos.forEach((video, index) => {
                const item = document.createElement('div');
                item.className = 'top-video-item';
                
                const playlist = video.playlist || '';
                const videoUrl = window.VideoID 
                    ? window.VideoID.buildVideoUrl(video.name, playlist)
                    : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist)}`;
                
                const hiddenLink = document.createElement('a');
                hiddenLink.href = videoUrl;
                hiddenLink.target = '_blank';
                hiddenLink.className = 'video-item-link';
                item.appendChild(hiddenLink);
                
                const thumb = document.createElement('div');
                thumb.className = 'top-video-thumb';
                
                const rank = document.createElement('div');
                rank.className = `top-video-rank rank-${index + 1}`;
                rank.textContent = index + 1;
                thumb.appendChild(rank);
                
                thumb.innerHTML += `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:12px;text-align:center;">${getFileNameWithoutExtension(video.name).substring(0, 12)}...</div>`;
                
                const info = document.createElement('div');
                info.className = 'top-video-info';
                const danmakuCount = video.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(video.name) : 0);
                const createdDateObj = video.created ? new Date(video.created) : (video.modified ? new Date(video.modified) : null);
                const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
                const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
                const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
                const dateLine = dateStr ? `<div class="top-video-date" style="color:#888;font-size:11px;">${dateStr}</div>` : '';
                const statsLine = `<div class="top-video-meta" style="color:#888;font-size:11px;">${viewsSvg} ${(video.views || 0).toLocaleString()} • ${danmakuSvg} ${danmakuCount}</div>`;
                info.innerHTML = `
                    <div class="top-video-title">${escapeHtml(getFileNameWithoutExtension(video.name))}</div>
                    ${dateLine}
                    ${statsLine}
                `;
                
                item.appendChild(thumb);
                item.appendChild(info);
                
                item.addEventListener('click', () => {
                    window.location.href = videoUrl;
                });
                
                topVideosList.appendChild(item);
                
                getPreviewAndDuration(video).then(({ preview }) => {
                    thumb.innerHTML = '';
                    if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                        thumb.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';" />`;
                    } else {
                        thumb.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:12px;text-align:center;">${getFileNameWithoutExtension(video.name).substring(0, 12)}...</div>`;
                    }
                    
                    const newRank = document.createElement('div');
                    newRank.className = `top-video-rank rank-${index + 1}`;
                    newRank.textContent = index + 1;
                    thumb.appendChild(newRank);
                }).catch(() => {
                    const existingRank = thumb.querySelector('.top-video-rank');
                    if (!existingRank) {
                        const newRank = document.createElement('div');
                        newRank.className = `top-video-rank rank-${index + 1}`;
                        newRank.textContent = index + 1;
                        thumb.appendChild(newRank);
                    }
                });
            });
        }

        // Fix top 5 videos container background for dark theme
        function fixTopVideosBackground() {
            const isDarkTheme = document.documentElement.classList.contains('dark-theme');
            const topVideosContainer = document.getElementById('topVideosBlock');
            
            if (topVideosContainer && isDarkTheme) {
                topVideosContainer.style.background = '#000';
                topVideosContainer.style.border = 'none';
                topVideosContainer.style.borderRadius = '0';
                
                const heading = topVideosContainer.querySelector('h4');
                if (heading) {
                    heading.style.color = '#fff';
                }
            }
        }

        async function createThumbnail(file, maxSize = 200) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > height) {
                            if (width > maxSize) {
                                height = Math.round((height * maxSize) / width);
                                width = maxSize;
                            }
                        } else {
                            if (height > maxSize) {
                                width = Math.round((width * maxSize) / height);
                                height = maxSize;
                            }
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d', { alpha: true });
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Failed to create thumbnail'));
                            }
                        }, 'image/jpeg', 0.95);
                    };
                    
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = e.target.result;
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        }

        async function handleImageUpload(file, type) {
            if (!file || file.size > 5 * 1024 * 1024) {
                return;
            }
            
            try {
                const channelDir = await getChannelDirectory();
                const timestamp = Date.now();
                const extension = file.name.split('.').pop();
                const baseFileName = `${type}_${timestamp}`;
                
                const originalFileName = `${baseFileName}_original.${extension}`;
                const originalData = Array.from(new Uint8Array(await file.arrayBuffer()));
                await saveImageFile(channelDir, originalFileName, originalData);
                
                let thumbnailFileName = null;
                if (type === 'avatar') {
                    const thumbnailBlob = await createThumbnail(file, 200);
                    thumbnailFileName = `${baseFileName}_thumb.jpg`;
                    const thumbnailData = Array.from(new Uint8Array(await thumbnailBlob.arrayBuffer()));
                    await saveImageFile(channelDir, thumbnailFileName, thumbnailData);
                }
                
                if (type === 'avatar') {
                    channelData.avatar = thumbnailFileName;
                    channelData.avatarOriginal = originalFileName;
                } else if (type === 'header') {
                    channelData.header = originalFileName;
                } else if (type === 'background') {
                    channelData.background = originalFileName;
                }
                
                await saveChannelData();
                await renderChannel();
                
                if (type === 'avatar') {
                    const authorAvatarEl = document.getElementById('authorAvatar');
                    if (authorAvatarEl) {
                        if (channelData.avatar) {
                            const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                            if (avatarUrl) {
                                authorAvatarEl.innerHTML = `<img src="${avatarUrl}" alt="Avatar" style="width:100%;height:100%;object-fit:cover;display:block;">`;
                            }
                        } else {
                            authorAvatarEl.innerHTML = '';
                            authorAvatarEl.textContent = currentChannelName.charAt(0).toUpperCase();
                        }
                    }
                }
            } catch (e) {
                console.error('Error uploading image:', e);
            }
        }

        async function getPreviewAndDuration(item) {
            if (item._cachedPreview && item._cachedDuration && item._cachedDuration !== '0:00') {
                return { preview: item._cachedPreview, duration: item._cachedDuration };
            }
            
            const hasValidPreview = item.preview && item.preview.length > 50 && !item.preview.includes('blob:null/');
            const hasValidDuration = item.duration && item.duration !== '0:00' && item.duration !== 0;
            
            if (hasValidPreview && hasValidDuration) {
                item._cachedPreview = item.preview;
                item._cachedDuration = item.duration;
                return { preview: item.preview, duration: item.duration };
            }

            const dirHandle = item.directoryHandle || item.dirHandle || videoDirectoryHandle;
            
            const cacheKey = `${item.name}_${item.size}_${item.modified}`;
            if (previewCache.has(cacheKey)) {
                const cached = previewCache.get(cacheKey);
                return { preview: cached.preview, duration: cached.duration };
            }
            
            let actualSize = item.size;
            let actualModified = item.modified;
            
            if (!actualSize || !actualModified) {
                try {
                    const fileHandle = await dirHandle.getFileHandle(item.name);
                    const file = await fileHandle.getFile();
                    actualSize = file.size;
                    actualModified = file.lastModified;
                } catch (e) {
                }
            }
            
            const meta = await getVideoMetadata(dirHandle, item.name);
            const canCheckFileChanged = actualSize && actualModified && meta.size && meta.modified;
            const fileChanged = canCheckFileChanged && (meta.size !== actualSize || meta.modified !== actualModified);
            
            if (meta.preview && meta.duration && !fileChanged) {
                const result = { preview: meta.preview, duration: meta.duration };
                previewCache.set(cacheKey, { 
                    ...result, 
                    timestamp: Date.now() 
                });
                item._cachedPreview = meta.preview;
                item._cachedDuration = meta.duration;
                return result;
            }

            try {
                const db = await openDB();
                
                if (db && db.objectStoreNames.contains('videos')) {
                    const cachedVideo = await getFromDBGeneric(db, 'videos', item.name);
                    if (cachedVideo && cachedVideo.preview && !fileChanged) {
                        const result = { preview: cachedVideo.preview, duration: cachedVideo.duration || '0:00' };
                        previewCache.set(cacheKey, { 
                            ...result, 
                            timestamp: Date.now() 
                        });
                        item._cachedPreview = cachedVideo.preview;
                        item._cachedDuration = cachedVideo.duration || '0:00';
                        return result;
                    }
                }
                
                if (item.name && typeof item.name === 'string' && item.name.length > 0) {
                    const oldCacheKey = 'preview_' + item.name;
                    const cachedPreview = await getFromDBCompat(db, oldCacheKey);
                    if (cachedPreview && cachedPreview.preview && !fileChanged) {
                        const result = { preview: cachedPreview.preview, duration: cachedPreview.duration || '0:00' };
                        previewCache.set(cacheKey, { 
                            ...result, 
                            timestamp: Date.now() 
                        });
                        item._cachedPreview = cachedPreview.preview;
                        item._cachedDuration = cachedPreview.duration || '0:00';
                        return result;
                    }
                }
            } catch (e) {
                console.warn('Failed to get from IndexedDB cache:', e);
            }
            
            console.warn(`No preview found for video: ${item.name} - channel view is read-only`);
            return {
                preview: null,
                duration: '0:00'
            };
        }

        async function generateVideoPreview(item) {
            const video = document.createElement('video');
            video.muted = true;
            video.playsInline = true;
            video.preload = 'metadata';
            const url = URL.createObjectURL(item.file);
            video.src = url;

            await new Promise((resolve, reject) => {
                video.addEventListener('loadedmetadata', resolve, { once: true });
                video.addEventListener('error', reject, { once: true });
            });

            video.currentTime = video.duration / 2;

            await new Promise((resolve, reject) => {
                video.addEventListener('seeked', resolve, { once: true });
                video.addEventListener('error', reject, { once: true });
            });

            const canvas = document.createElement('canvas');
            canvas.width = 240;
            canvas.height = 140;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, 240, 140);
            const previewData = canvas.toDataURL('image/jpeg', 0.7);
            const duration = formatDuration(video.duration);
            URL.revokeObjectURL(url);
            
            return { preview: previewData, duration };
        }

        function formatDuration(sec) {
            if (!isFinite(sec) || sec <= 0) return '0:00';
            const s = Math.round(sec);
            const m = Math.floor(s / 60);
            const ss = String(s % 60).padStart(2, '0');
            return `${m}:${ss}`;
        }

        async function saveVideoMetadata(dirHandle, fileName, metadata) {
            try {
                // Read existing metadata to preserve created timestamp
                const existingMeta = await getVideoMetadata(dirHandle, fileName);
                
                // Merge with existing, preserving created field
                const safeMeta = {
                    ...existingMeta,
                    ...metadata,
                    // CRITICAL: Always preserve the original created timestamp
                    created: existingMeta.created || metadata.created || Date.now(),
                    fileCreated: existingMeta.fileCreated || metadata.fileCreated
                };
                
                const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                const metaFileName = fileName + '.meta.json';
                const fileHandle = await metaDir.getFileHandle(metaFileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(safeMeta, null, 2));
                await writable.close();
            } catch (e) {
                console.error('Error saving video metadata:', e);
            }
        }

        async function loadPinnedVideo() {
            const pinnedVideoContainer = document.getElementById('pinnedVideo');
            if (!pinnedVideoContainer) return;
            
            if (channelData.pinnedVideo) {
                const video = channelVideos.find(v => v.name === channelData.pinnedVideo);
                if (video) {
                    pinnedVideoContainer.innerHTML = `
                        <div style="display:flex;gap:15px;align-items:flex-start;">
                            <div style="width:200px;height:112px;background:#000;position:relative;flex-shrink:0;border-radius:6px;overflow:hidden;">
                                <div id="pinnedThumb" style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;">Loading...</div>
                                <div style="position:absolute;bottom:4px;right:4px;background:rgba(0,0,0,0.8);color:white;padding:2px 4px;border-radius:2px;font-size:11px;">${video.duration || '0:00'}</div>
                            </div>
                            <div style="flex:1;min-width:0;">
                                <h4 style="margin:0 0 8px 0;font-size:16px;">${escapeHtml(getFileNameWithoutExtension(video.name))}</h4>
                                <div style="font-size:13px;color:#666;margin-bottom:8px;">
                                    ${new Date(video.created || video.modified).toLocaleDateString()} • ${video.views || 0} views
                                </div>
                                <div style="display:flex;gap:8px;">
                                    <button onclick="playPinnedVideo()" class="btn primary">Смотреть</button>
                                    <button onclick="unpinVideo()" class="btn secondary">Открепить</button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    getPreviewAndDuration(video).then(({ preview }) => {
                        const thumbEl = document.getElementById('pinnedThumb');
                        if (thumbEl) {
                            if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                                thumbEl.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';" />`;
                            } else {
                                thumbEl.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;font-size:10px;text-align:center;">${getFileNameWithoutExtension(video.name)}</div>`;
                            }
                        }
                    }).catch(() => {
                        const thumbEl = document.getElementById('pinnedThumb');
                        if (thumbEl) {
                            thumbEl.textContent = getFileNameWithoutExtension(video.name).substring(0, 15) + '...';
                        }
                    });
                } else {
                    channelData.pinnedVideo = null;
                    await saveChannelData();
                    loadPinnedVideo();
                }
            } else {
                const noPinnedText = typeof i18n !== 'undefined' ? i18n.t('channelView.noPinnedVideo') : 'Нет закрепленного видео';
                const noPinnedHint = typeof i18n !== 'undefined' ? i18n.t('channelView.noPinnedVideoHint') : 'Наведите на видео во вкладке "Видео" и нажмите на иконку скрепки для закрепления';
                pinnedVideoContainer.innerHTML = `
                    <div style="text-align:center;color:#999;padding:40px 20px">
                        <div style="font-size:16px;margin-bottom:10px">${noPinnedText}</div>
                        <div style="font-size:12px;color:#666;">${noPinnedHint}</div>
                    </div>
                `;
            }
        }


        async function pinVideo(videoName) {
            channelData.pinnedVideo = videoName;
            await saveChannelData();
            await loadPinnedVideo();
            
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        async function unpinVideo() {
            channelData.pinnedVideo = null;
            await saveChannelData();
            await loadPinnedVideo();
        }

        function playPinnedVideo() {
            if (channelData.pinnedVideo) {
                const video = channelVideos.find(v => v.name === channelData.pinnedVideo);
                if (video) {
                    const playlist = video.playlist || '';
                    window.location.href = window.VideoID ? window.VideoID.buildVideoUrl(video.name, playlist) : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist)}`;
                }
            }
        }

        function getFileNameWithoutExtension(fileName) {
            return fileName.replace(/\.[^/.]+$/, '');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function fmtBytes(n) {
            if (n < 1024) return n + ' B';
            if (n < 1024 * 1024) return (n / 1024).toFixed(1) + ' KB';
            return (n / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function naturalSortByName(arr) {
            return [...arr].sort((a, b) => {
                const an = getFileNameWithoutExtension(a.name) || '';
                const bn = getFileNameWithoutExtension(b.name) || '';
                return an.localeCompare(bn, undefined, { numeric: true, sensitivity: 'base' });
            });
        }

        function naturalSort(a, b) {
            return String(a).localeCompare(String(b), undefined, { numeric: true, sensitivity: 'base' });
        }

        function naturalCompareNames(aName, bName) {
            const strip = (s) => String(s || '').replace(/\.[^/.]+$/,'');
            return strip(aName).localeCompare(strip(bName), undefined, { numeric: true, sensitivity: 'base' });
        }

        async function showCreatePlaylistModal() {
            const modal = document.getElementById('createPlaylistModal');
            const videoList = document.getElementById('videoList');
            const searchInput = document.getElementById('videoSearch');
            document.getElementById('newPlaylistTitle').value = '';
            document.getElementById('newPlaylistCategories').value = '';
            searchInput.value = '';
            selectedVideoIds.clear();
            modal.style.display = 'flex';
            const loadingText = typeof i18n !== 'undefined' ? i18n.t('channelView.loadingVideos') : 'Загрузка видео...';
            videoList.innerHTML = `<div class="loading">${loadingText}</div>`;

            if (channelVideos.length === 0) await loadAllChannelVideos();
            createModalVideoOrder = [...channelVideos];
            renderVideoList(createModalVideoOrder);
        }

        function renderVideoList(videos) {
            const list = document.getElementById('videoList');
            const counter = document.getElementById('selectionCounter');
            const selectedText = typeof i18n !== 'undefined' ? i18n.t('channelView.selected') : 'Выбрано';

            if (!videos || videos.length === 0) {
                const noVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.noVideosToAdd') : 'Нет видео для добавления';
                list.innerHTML = `<div class="empty-state">${noVideosText}</div>`;
                counter.textContent = `${selectedText}: 0`;
                return;
            }

            list.innerHTML = '';
            const sorted = naturalSortByName(videos);
            sorted.forEach((video, i) => {
                const item = document.createElement('div');
                item.className = 'video-list-item';
                item.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px 12px;border-bottom:1px solid #eee;cursor:pointer;position:relative';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.id = `video_${i}`;
                cb.dataset.index = String(i);
                cb.checked = selectedVideoIds.has(video.name);
                cb.addEventListener('change', (e) => {
                    const videoName = video.name;
                    if (e.target.checked) {
                        selectedVideoIds.add(videoName);
                    } else {
                        selectedVideoIds.delete(videoName);
                    }
                    updateSelectionCounter();
                });

                const label = document.createElement('label');
                label.htmlFor = cb.id;
                label.textContent = getFileNameWithoutExtension(video.name);
                label.style.cssText = 'flex:1;font-size:13px;cursor:pointer;margin:0';

                const meta = document.createElement('div');
                meta.style.cssText = 'font-size:11px;color:#666;margin-left:auto;';
                const views = video.views || 0;
                meta.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 3px;">👁 ${views} ${getViewsWord(views)}</span> • ${new Date(video.modified).toLocaleDateString()}`;

                item.appendChild(cb);
                item.appendChild(label);
                item.appendChild(meta);
                list.appendChild(item);
            });
            updateSelectionCounter();
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selectionCounter');
            const count = document.querySelectorAll('#videoList input[type="checkbox"]:checked').length;
            const selectedText = typeof i18n !== 'undefined' ? i18n.t('channelView.selected') : 'Выбрано';
            counter.textContent = `${selectedText}: ${count}`;
        }

        function searchVideos() {
            const term = document.getElementById('videoSearch').value.toLowerCase();
            const filtered = term ? createModalVideoOrder.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(term)) : createModalVideoOrder;
            renderVideoList(naturalSortByName(filtered));
        }

        async function createChannelPlaylist() {
            const title = document.getElementById('newPlaylistTitle').value.trim();
            const categoriesInput = document.getElementById('newPlaylistCategories').value.trim();

            if (!title) {
                alert('Введите название плейлиста');
                return;
            }

            const categories = categoriesInput
                ? categoriesInput.split(',').map(cat => cat.trim()).filter(cat => cat)
                : [];

            const selected = [];
            const allSelectedVideos = [];
            selectedVideoIds.forEach(videoName => {
                const video = createModalVideoOrder.find(v => v.name === videoName);
                if (video) {
                    allSelectedVideos.push(video);
                }
            });
            const ordered = naturalSortByName(allSelectedVideos);

            ordered.forEach(video => {
                selected.push({
                    name: video.name,
                    size: video.size,
                    modified: video.modified,
                    created: video.created || Date.now(),
                    views: video.views || 0,
                    likes: video.likes || 0,
                    dislikes: video.dislikes || 0,
                    tags: video.tags || []
                });
            });

            if (selected.length === 0) {
                alert('Выберите хотя бы одно видео');
                return;
            }

            const playlist = {
                id: Date.now().toString(),
                title,
                categories,
                videos: selected,
                created: Date.now()
            };

            channelData.playlists = channelData.playlists || [];
            channelData.playlists.push(playlist);

            await saveChannelData();
            await loadPlaylists();

            document.getElementById('createPlaylistModal').style.display = 'none';
        }

        async function editPlaylist(playlist) {
            currentEditingPlaylist = playlist;
            editingSelectedVideos.clear();

            const modal = document.getElementById('editPlaylistModal');
            const titleText = typeof i18n !== 'undefined' ? i18n.t('channelView.editPlaylistTitle', {channel: currentChannelName}) : `Редактировать плейлист (${currentChannelName})`;
            document.querySelector('#editPlaylistModal .modal-header h3').textContent = titleText;
            document.getElementById('editPlaylistTitle').value = playlist.title || '';
            document.getElementById('editPlaylistCategories').value = (playlist.categories || []).join(', ');

            const typeInfo = document.getElementById('playlistTypeInfo');
            if (typeInfo) {
                typeInfo.textContent = `Канал: ${currentChannelName}`;
            }

            if (channelVideos.length === 0) await loadAllChannelVideos();

            const playlistVideos = [...(playlist.videos || [])];
            for (let v of playlistVideos) {
                const found = channelVideos.find(cv => cv.name === v.name);
                if (found) Object.assign(v, found);
            }

            renderEditPlaylistVideos(playlistVideos);
            modal.style.display = 'flex';
        }

        function renderEditPlaylistVideos(videos) {
            const list = document.getElementById('editPlaylistVideosList');
            const search = document.getElementById('editPlaylistVideoSearch');

            function render(arr) {
                if (!arr || arr.length === 0) {
                    list.innerHTML = '<div class="empty-state">В плейлисте нет видео</div>';
                    return;
                }

                list.innerHTML = '';
                arr.forEach((video, idx) => {
                    const row = document.createElement('div');
                    row.className = 'video-list-item';
                    row.draggable = true;
                    row.dataset.videoName = video.name;
                    row.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px;border-bottom:1px solid #e5e5e5;font-size:12px;position:relative;cursor:move;';

                    const dragHandle = document.createElement('div');
                    dragHandle.className = 'drag-handle';
                    dragHandle.textContent = '⋮⋮';
                    dragHandle.style.cssText = 'cursor:move;color:#666;font-size:12px;margin-right:4px;';

                    const content = document.createElement('div');
                    content.style.cssText = 'display:flex;align-items:center;gap:8px;flex:1;';
                    const views = video.views || 0;
                    content.innerHTML = `
                        <div style="font-size:11px;color:#606060;min-width:15px;">${idx+1}</div>
                        <div style="flex:1;min-width:0;">
                            <div style="font-weight:500;">${escapeHtml(getFileNameWithoutExtension(video.name))}</div>
                            <div style="font-size:10px;color:#666;display:flex;align-items:center;gap:3px;">👁 ${views} ${getViewsWord(views)}</div>
                        </div>
                    `;

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = typeof i18n !== 'undefined' ? i18n.t('channelView.remove') : 'Удалить';
                    removeBtn.style.cssText = 'background:#d94b88;color:white;border:none;border-radius:3px;padding:2px 6px;font-size:10px;cursor:pointer;';
                    removeBtn.onclick = () => removeVideoFromEdit(video.name);

                    row.addEventListener('dragstart', (e) => {
                        row.classList.add('dragging');
                        e.dataTransfer.setData('text/plain', video.name);
                        e.dataTransfer.effectAllowed = 'move';
                    });

                    row.addEventListener('dragend', () => {
                        row.classList.remove('dragging');
                        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    });

                    row.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        row.classList.add('drag-over');
                    });

                    row.addEventListener('dragleave', () => {
                        row.classList.remove('drag-over');
                    });

                    row.addEventListener('drop', (e) => {
                        e.preventDefault();
                        row.classList.remove('drag-over');
                        const draggedVideoName = e.dataTransfer.getData('text/plain');
                        reorderVideosInEditModal(draggedVideoName, video.name);
                    });

                    row.appendChild(dragHandle);
                    row.appendChild(content);
                    row.appendChild(removeBtn);
                    list.appendChild(row);
                });
            }

            render(videos);

            search.oninput = () => {
                const q = search.value.toLowerCase();
                const filtered = q ? videos.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(q)) : videos;
                render(filtered);
            };

            search.value = '';
        }

        function reorderVideosInEditModal(draggedVideoName, targetVideoName) {
            if (draggedVideoName === targetVideoName) return;

            const videosArray = currentEditingPlaylist.videos;
            const draggedIndex = videosArray.findIndex(v => v.name === draggedVideoName);
            const targetIndex = videosArray.findIndex(v => v.name === targetVideoName);

            if (draggedIndex === -1 || targetIndex === -1) return;

            const [draggedVideo] = videosArray.splice(draggedIndex, 1);
            videosArray.splice(targetIndex, 0, draggedVideo);

            renderEditPlaylistVideos(videosArray);
        }

        function removeVideoFromEdit(videoName) {
            currentEditingPlaylist.videos = currentEditingPlaylist.videos.filter(v => v.name !== videoName);
            renderEditPlaylistVideos(currentEditingPlaylist.videos);
        }

        function showAddVideosModal() {
            editingSelectedVideos.clear();
            const modal = document.getElementById('addVideosModal');
            const list = document.getElementById('addVideoList');
            const search = document.getElementById('addVideoSearch');

            search.value = '';
            list.innerHTML = '<div class="loading">Загрузка видео...</div>';
            modal.style.display = 'flex';

            const modalTitle = document.querySelector('#addVideosModal .modal-header h3');
            if (modalTitle) {
                modalTitle.textContent = `Добавить видео в плейлист (${currentChannelName})`;
            }

            const existingNames = new Set((currentEditingPlaylist.videos || []).map(v => v.name));
            const availableVideos = channelVideos.filter(v => !existingNames.has(v.name));

            const searchInfo = document.querySelector('#addVideosModal .search-info');
            if (searchInfo) {
                const availableText = typeof i18n !== 'undefined' ? i18n.t('channelView.available') : 'Доступно';
                const channelVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.channelVideosCount') : 'видео канала';
                searchInfo.textContent = `${availableText}: ${availableVideos.length} ${channelVideosText}`;
            }

            if (availableVideos.length === 0) {
                const allAddedText = typeof i18n !== 'undefined' ? i18n.t('channelView.allVideosAlreadyAdded') : 'Все видео канала уже добавлены в плейлист';
                list.innerHTML = `<div class="empty-state">${allAddedText}</div>`;
                return;
            }

            renderAddVideoList(availableVideos);
        }

        function renderAddVideoList(videos) {
            const list = document.getElementById('addVideoList');
            const counter = document.getElementById('addSelectionCounter');
            const selectedText = typeof i18n !== 'undefined' ? i18n.t('channelView.selected') : 'Выбрано';
            const availableText = typeof i18n !== 'undefined' ? i18n.t('channelView.available') : 'Доступно';
            const channelVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.channelVideosCount') : 'видео канала';
            const allAddedText = typeof i18n !== 'undefined' ? i18n.t('channelView.allVideosAlreadyAdded') : 'Все видео канала уже добавлены в плейлист';

            if (!videos || videos.length === 0) {
                list.innerHTML = `<div class="empty-state">${allAddedText}</div>`;
                counter.textContent = `${selectedText}: 0`;

                const searchInfo = document.querySelector('#addVideosModal .search-info');
                if (searchInfo) {
                    searchInfo.textContent = `${availableText}: 0 ${channelVideosText}`;
                }
                return;
            }

            list.innerHTML = '';
            const sorted = naturalSortByName(videos);
            sorted.forEach((video, i) => {
                const item = document.createElement('div');
                item.className = 'video-list-item';
                item.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px 12px;border-bottom:1px solid #eee;cursor:pointer;position:relative';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.id = `addVideo_${i}`;
                cb.checked = editingSelectedVideos.has(video.name);
                cb.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        editingSelectedVideos.add(video.name);
                    } else {
                        editingSelectedVideos.delete(video.name);
                    }
                    updateAddSelectionCounter();
                });

                const label = document.createElement('label');
                label.htmlFor = cb.id;
                label.textContent = getFileNameWithoutExtension(video.name);
                label.style.cssText = 'flex:1;font-size:13px;cursor:pointer;margin:0';

                const meta = document.createElement('div');
                meta.style.cssText = 'font-size:11px;color:#666;margin-left:auto;';
                const views = video.views || 0;
                meta.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 3px;">👁 ${views} ${getViewsWord(views)}</span> • ${new Date(video.modified).toLocaleDateString()}`;

                item.appendChild(cb);
                item.appendChild(label);
                item.appendChild(meta);
                list.appendChild(item);
            });

            updateAddSelectionCounter();
        }

        function updateAddSelectionCounter() {
            const counter = document.getElementById('addSelectionCounter');
            const selectedText = typeof i18n !== 'undefined' ? i18n.t('channelView.selected') : 'Выбрано';
            counter.textContent = `${selectedText}: ${editingSelectedVideos.size}`;
        }

        function searchAddVideos() {
            const term = document.getElementById('addVideoSearch').value.toLowerCase();
            const existingNames = new Set((currentEditingPlaylist.videos || []).map(v => v.name));
            const availableVideos = channelVideos.filter(v => !existingNames.has(v.name));
            const filtered = term ? availableVideos.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(term)) : availableVideos;

            const searchInfo = document.querySelector('#addVideosModal .search-info');
            if (searchInfo) {
                const availableText = typeof i18n !== 'undefined' ? i18n.t('channelView.available') : 'Доступно';
                const channelVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.channelVideosCount') : 'видео канала';
                searchInfo.textContent = `${availableText}: ${availableVideos.length} ${channelVideosText}`;
            }

            renderAddVideoList(naturalSortByName(filtered));
        }

        function addSelectedVideosToPlaylist() {
            if (editingSelectedVideos.size === 0) {
                alert('Выберите хотя бы одно видео');
                return;
            }

            const updatedVideos = [...currentEditingPlaylist.videos];

            editingSelectedVideos.forEach(videoName => {
                const video = channelVideos.find(v => v.name === videoName);
                if (video) {
                    updatedVideos.push({
                        name: video.name,
                        size: video.size,
                        modified: video.modified,
                        created: video.created || Date.now(),
                        views: video.views || 0,
                        likes: video.likes || 0,
                        dislikes: video.dislikes || 0,
                        tags: video.tags || []
                    });
                }
            });

            currentEditingPlaylist.videos = updatedVideos;
            renderEditPlaylistVideos(currentEditingPlaylist.videos);
            document.getElementById('addVideosModal').style.display = 'none';
            editingSelectedVideos.clear();

            const searchInfo = document.querySelector('#addVideosModal .search-info');
            if (searchInfo) {
                const existingNames = new Set((currentEditingPlaylist.videos || []).map(v => v.name));
                const availableVideos = channelVideos.filter(v => !existingNames.has(v.name));
                const availableText = typeof i18n !== 'undefined' ? i18n.t('channelView.available') : 'Доступно';
                const channelVideosText = typeof i18n !== 'undefined' ? i18n.t('channelView.channelVideosCount') : 'видео канала';
                searchInfo.textContent = `${availableText}: ${availableVideos.length} ${channelVideosText}`;
            }
        }

        async function saveEditedPlaylist() {
            const title = document.getElementById('editPlaylistTitle').value.trim();
            const categoriesInput = document.getElementById('editPlaylistCategories').value.trim();

            if (!title) {
                alert('Введите название плейлиста');
                return;
            }

            const categories = categoriesInput
                ? categoriesInput.split(',').map(cat => cat.trim()).filter(cat => cat)
                : [];

            currentEditingPlaylist.title = title;
            currentEditingPlaylist.categories = categories;

            try {
                const playlistIndex = (channelData.playlists || []).findIndex(p => p.id === currentEditingPlaylist.id);
                if (playlistIndex !== -1) {
                    channelData.playlists[playlistIndex] = currentEditingPlaylist;
                } else {
                    channelData.playlists.push(currentEditingPlaylist);
                }

                await saveChannelData();
                await loadPlaylists();

                document.getElementById('editPlaylistModal').style.display = 'none';
            } catch (e) {
                console.error('saveEditedPlaylist error', e);
                alert('Ошибка при сохранении плейлиста');
            }
        }

        async function deletePlaylist(playlist) {
            const confirmMsg = typeof i18n !== 'undefined' ? i18n.t('channelView.confirmDeletePlaylist', {title: playlist.title}) : `Удалить плейлист "${playlist.title}"?`;
            if (!confirm(confirmMsg)) return;

            try {
                channelData.playlists = (channelData.playlists || []).filter(p => p.id !== playlist.id);
                await saveChannelData();
                await loadPlaylists();
            } catch (e) {
                console.error('deletePlaylist error', e);
                alert('Ошибка при удалении плейлиста');
            }
        }

        async function parallelLimit(tasks, limit = 4) {
            const results = [];
            const executing = new Set();
            for (const task of tasks) {
                const p = Promise.resolve().then(() => task());
                results.push(p);
                executing.add(p);
                p.finally(() => executing.delete(p));
                if (executing.size >= limit) {
                    await Promise.race(executing);
                }
            }
            return Promise.all(results);
        }

        function sortVideos(videos, sortType) {
            if (CHANNEL_VIEW_DEBUG) console.log('sortVideos called with sortType:', sortType, 'and', videos.length, 'videos');
            
            if (sortType === 'new' || sortType === 'default') {
                const sorted = videos.slice().sort((a, b) => (b.created || b.modified || 0) - (a.created || a.modified || 0));
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by new, first video:', sorted[0]?.name, 'created:', sorted[0]?.created, 'modified:', sorted[0]?.modified);
                return sorted;
            }
            if (sortType === 'old') {
                const sorted = videos.slice().sort((a, b) => (a.created || a.modified || 0) - (b.created || b.modified || 0));
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by old, first video:', sorted[0]?.name, 'created:', sorted[0]?.created, 'modified:', sorted[0]?.modified);
                return sorted;
            }
            if (sortType === 'popular') {
                const sorted = videos.slice().sort((a, b) => (b.views || 0) - (a.views || 0));
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by popular, first video:', sorted[0]?.name, 'views:', sorted[0]?.views);
                return sorted;
            }
            if (sortType === 'alpha' || sortType === 'alphabetical') {
                const sorted = videos.slice().sort((a, b) => naturalSort(getFileNameWithoutExtension(a.name), getFileNameWithoutExtension(b.name)));
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by alphabetical, first video:', sorted[0]?.name);
                return sorted;
            }
            if (sortType === 'random') {
                const sorted = videos.slice().sort(() => Math.random() - 0.5);
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by random, first video:', sorted[0]?.name);
                return sorted;
            }
            if (sortType === 'danmaku') {
                const sorted = videos.slice().sort((a, b) => {
                    const aDanmaku = a.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(a.name) : 0);
                    const bDanmaku = b.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(b.name) : 0);
                    return bDanmaku - aDanmaku;
                });
                if (CHANNEL_VIEW_DEBUG) console.log('Sorted by danmaku, first video:', sorted[0]?.name);
                return sorted;
            }
            
            const sorted = videos.slice().sort((a, b) => (b.created || b.modified || 0) - (a.created || a.modified || 0));
            if (CHANNEL_VIEW_DEBUG) console.log('Default sort, first video:', sorted[0]?.name);
            return sorted;
        }

        function sortPlaylists(playlists, sortType) {
            switch (sortType) {
                case 'new':
                    return [...playlists].sort((a, b) => (b.created || 0) - (a.created || 0));
                case 'old':
                    return [...playlists].sort((a, b) => (a.created || 0) - (b.created || 0));
                case 'alpha':
                    return [...playlists].sort((a, b) => naturalSort(a.title || '', b.title || ''));
                case 'random':
                    return [...playlists].sort(() => Math.random() - 0.5);
                default:
                    return [...playlists];
            }
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                
                if (targetTab === 'feed') {
                    window.location.href = 'forum/forum_profile.html?nick=' + encodeURIComponent(currentChannelName);
                    return;
                }
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const sortingSection = document.getElementById('sortingSection');
                if (sortingSection) {
                    if (targetTab === 'videos' || targetTab === 'playlists') {
                        sortingSection.style.display = 'block';
                    } else {
                        sortingSection.style.display = 'none';
                    }
                }
                document.getElementById(targetTab + 'Tab').classList.add('active');
                
                updateURLWithTab(targetTab);
                
                if (targetTab === 'analytics' && channelAnalyticsInstance) {
                    taskQueue.add(async () => {
                        const analytics = await channelAnalyticsInstance.updateAnalytics(channelVideos);
                        channelAnalyticsInstance.renderAnalytics();
                        
                        if (channelAchievementsInstance) {
                            const newAchievements = channelAchievementsInstance.checkAchievements(analytics);
                            channelAchievementsInstance.renderAchievements();
                            
                            if (newAchievements.length > 0) {
                                showAchievementNotification(newAchievements);
                            }
                        }
                        
                        return analytics;
                    }, 2);
                }
            });
        });

        document.querySelectorAll('[id^="grid"]').forEach(btn => {
            btn.addEventListener('click', () => {
                const gridMode = btn.id.replace('grid', '').replace('BtnChan', '');
                document.querySelectorAll('[id^="grid"]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const grid = document.getElementById('videosGrid');
                if (grid) {
                    grid.style.gridTemplateColumns = `repeat(${gridMode}, 1fr)`;
                    
                    if (typeof channelVideos !== 'undefined' && channelVideos.length > 0) {
                        renderVideosGrid(channelVideos);
                    }
                }
            });
        });

        

        document.addEventListener('DOMContentLoaded', async () => {
            const activeTab = getUrlParam('tab');
            if (activeTab && ['home', 'videos', 'analytics', 'feed', 'playlists', 'description'].includes(activeTab)) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`[data-tab="${activeTab}"]`).classList.add('active');

                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const sortingSection = document.getElementById('sortingSection');
                if (sortingSection) {
                    if (activeTab === 'videos' || activeTab === 'playlists') {
                        sortingSection.style.display = 'block';
                    } else {
                        sortingSection.style.display = 'none';
                    }
                }
                document.getElementById(activeTab + 'Tab').classList.add('active');
                
                document.querySelectorAll('#sortingSection .sidebar-item').forEach(item => item.classList.remove('active'));
                const activeSortElement = document.getElementById(`sort${currentSort.charAt(0).toUpperCase() + currentSort.slice(1)}`);
                if (activeSortElement) {
                    activeSortElement.classList.add('active');
                }
            } else {
                document.querySelectorAll('#sortingSection .sidebar-item').forEach(item => item.classList.remove('active'));
                const activeSortElement = document.getElementById(`sort${currentSort.charAt(0).toUpperCase() + currentSort.slice(1)}`);
                if (activeSortElement) {
                    activeSortElement.classList.add('active');
                }
            }
            
            const allTagsLink = document.getElementById('allTagsLink');
            if (allTagsLink) {
                allTagsLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
                    allTagsLink.classList.add('active');
                    
                    renderVideos(channelVideos);
                });
            }


        const sortDefault = document.getElementById('sortDefault');
        const sortNew = document.getElementById('sortNew');
        const sortPopular = document.getElementById('sortPopular');
        const sortOld = document.getElementById('sortOld');
        const sortRandom = document.getElementById('sortRandom');
        const sortAlphabetical = document.getElementById('sortAlphabetical');

        if (sortDefault) {
            sortDefault.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortDefault.classList.add('active');
                
                 currentSort = 'default';
                 
                 const sortedVideos = sortVideos(channelVideos, 'default');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        if (sortNew) {
            sortNew.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortNew.classList.add('active');
                
                 currentSort = 'new';
                 
                 const sortedVideos = sortVideos(channelVideos, 'new');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        if (sortPopular) {
            sortPopular.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortPopular.classList.add('active');
                
                 currentSort = 'popular';
                 
                 const sortedVideos = sortVideos(channelVideos, 'popular');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        if (sortOld) {
            sortOld.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortOld.classList.add('active');
                
                 currentSort = 'old';
                 
                 const sortedVideos = sortVideos(channelVideos, 'old');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        if (sortRandom) {
            sortRandom.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortRandom.classList.add('active');
                
                 currentSort = 'random';
                 
                 const sortedVideos = sortVideos(channelVideos, 'random');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        if (sortAlphabetical) {
            sortAlphabetical.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortAlphabetical.classList.add('active');
                
                 currentSort = 'alphabetical';
                 
                 const sortedVideos = sortVideos(channelVideos, 'alpha');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }

        const sortDanmaku = document.getElementById('sortDanmaku');
        if (sortDanmaku) {
            sortDanmaku.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('#sortDefault, #sortNew, #sortPopular, #sortOld, #sortRandom, #sortAlphabetical, #sortDanmaku').forEach(item => item.classList.remove('active'));
                sortDanmaku.classList.add('active');
                
                 currentSort = 'danmaku';
                 
                 const sortedVideos = sortVideos(channelVideos, 'danmaku');
                 renderVideos(sortedVideos);
                 
                 if (document.querySelector('[data-tab="playlists"]').classList.contains('active')) {
                     loadPlaylists();
                 }
            });
        }
            if (!supportsFS) {
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red"><strong>File System API не поддерживается в этом браузере. Используйте Chrome/Edge.</strong></div>';
                return;
            }

            currentChannelName = getUrlParam('channel');
            if (!currentChannelName) {
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>Канал не найден</strong></div>';
                return;
            }

            const grid3Btn = document.getElementById('grid3BtnChan');
            const grid4Btn = document.getElementById('grid4BtnChan');
            const grid5Btn = document.getElementById('grid5BtnChan');
            const grid6Btn = document.getElementById('grid6BtnChan');
            const videosTab = document.getElementById('videosTab');
            const videosGrid = document.getElementById('videosGrid');
            [grid3Btn, grid4Btn, grid5Btn, grid6Btn].forEach(btn => btn && btn.classList.remove('active'));
            if (grid6Btn) grid6Btn.classList.add('active');
            if (videosGrid) videosGrid.style.gridTemplateColumns = 'repeat(6,1fr)';

            document.getElementById('sortNew').classList.add('active');

            if (!getUrlParam('tab')) {
                updateURLWithTab('home');
            }

            try {
                const db = await openDB();
                const savedHandle = await getFromDB(db, 'videoDirectoryHandle');
                
                if (savedHandle) {
                    const permission = await savedHandle.queryPermission();
                    if (permission === 'granted' || (permission === 'prompt' && await savedHandle.requestPermission() === 'granted')) {
                        videoDirectoryHandle = savedHandle;
                        
                        await loadChannelData();
                        await setupSubscriptionButton();
                        setupQMSButton();
                        setupForumButton();
                        
                        // Load danmaku counts BEFORE rendering
                        if (window.DanmakuCounter) {
                          await window.DanmakuCounter.load(videoDirectoryHandle, channelVideos);
                        }
                        
                        const loadBackgroundData = async () => {
                            try {
                               if (CHANNEL_VIEW_DEBUG)   console.log('⏳ Loading background data...');
                                
                                await syncSubscriptions();
                                await renderSubscribedChannelsList();
                                
                                try {
                                    const searchInput = document.getElementById('headerSearchInput');
                                    if (searchInput && typeof AutocompleteIntegration !== 'undefined' && typeof YouviAutocomplete !== 'undefined') {
                                        const { videos, playlists } = typeof AutocompleteDataLoader !== 'undefined' 
                                          ? await AutocompleteDataLoader.loadData() 
                                          : { videos: [], playlists: [] };
                                        
                                        const cacheValid = await window.autocompleteCache.isCacheValid(
                                            videos.length,
                                            playlists.length
                                        );
                                        
                                        const autocompleteIntegration = new AutocompleteIntegration();
                                        await autocompleteIntegration.init(searchInput, {
                                          videoDirectoryHandle: videoDirectoryHandle,
                                          allVideos: cacheValid ? [] : videos,
                                          allPlaylists: cacheValid ? [] : playlists
                                        });
                                        if (CHANNEL_VIEW_DEBUG) console.log('[Autocomplete] ✅ Initialized on youvi_ch_view.html');
                                    }
                                } catch (error) {
                                    if (CHANNEL_VIEW_DEBUG) console.error('[Autocomplete] Failed to initialize:', error);
                                }
                                
                                if (CHANNEL_VIEW_DEBUG) console.log('✅ Background data loaded');
                            } catch (error) {
                                if (CHANNEL_VIEW_DEBUG) console.error('[Background] Error loading data:', error);
                            }
                        };
                        
                        setTimeout(() => loadBackgroundData(), 100);
                    } else {
                        document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>Нет доступа к папке с видео</strong></div>';
                    }
                } else {
                    document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>Сначала выберите папку с видео на главной странице</strong></div>';
                }
            } catch (e) {
                if (CHANNEL_VIEW_DEBUG) console.error('Error accessing directory:', e);
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red"><strong>Ошибка доступа к файловой системе</strong></div>';
            }

            const createPlaylistBtn = document.getElementById('createPlaylist');
            if (createPlaylistBtn) {
                createPlaylistBtn.addEventListener('click', showCreatePlaylistModal);
            }

            const savePlaylistBtn = document.getElementById('savePlaylist');
            const cancelPlaylistBtn = document.getElementById('cancelPlaylist');
            if (savePlaylistBtn) {
                savePlaylistBtn.addEventListener('click', createChannelPlaylist);
            }
            if (cancelPlaylistBtn) {
                cancelPlaylistBtn.addEventListener('click', () => {
                    document.getElementById('createPlaylistModal').style.display = 'none';
                });
            }

            const videoSearchInput = document.getElementById('videoSearch');
            if (videoSearchInput) {
                videoSearchInput.addEventListener('input', searchVideos);
            }

            const selectAllVideosBtn = document.getElementById('selectAllVideos');
            if (selectAllVideosBtn) {
                selectAllVideosBtn.addEventListener('click', () => {
                    const searchTerm = document.getElementById('videoSearch').value.toLowerCase();
                    let currentVideos = searchTerm ?
                        createModalVideoOrder.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(searchTerm)) :
                        createModalVideoOrder;
                    currentVideos = naturalSortByName(currentVideos);

                    document.querySelectorAll('#videoList input[type="checkbox"]').forEach((cb, displayIndex) => {
                        cb.checked = true;
                        if (currentVideos[displayIndex]) {
                            selectedVideoIds.add(currentVideos[displayIndex].name);
                        }
                    });
                    updateSelectionCounter();
                });
            }

            const clearSelectionBtn = document.getElementById('clearSelection');
            if (clearSelectionBtn) {
                clearSelectionBtn.addEventListener('click', () => {
                    const searchTerm = document.getElementById('videoSearch').value.toLowerCase();
                    let currentVideos = searchTerm ?
                        createModalVideoOrder.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(searchTerm)) :
                        createModalVideoOrder;
                    currentVideos = naturalSortByName(currentVideos);

                    document.querySelectorAll('#videoList input[type="checkbox"]').forEach((cb, displayIndex) => {
                        cb.checked = false;
                        if (currentVideos[displayIndex]) {
                            selectedVideoIds.delete(currentVideos[displayIndex].name);
                        }
                    });
                    updateSelectionCounter();
                });
            }

            const addVideosToPlaylistBtn = document.getElementById('addVideosToPlaylist');
            const saveEditPlaylistBtn = document.getElementById('saveEditPlaylist');
            const cancelEditPlaylistBtn = document.getElementById('cancelEditPlaylist');
            if (addVideosToPlaylistBtn) {
                addVideosToPlaylistBtn.addEventListener('click', showAddVideosModal);
            }
            if (saveEditPlaylistBtn) {
                saveEditPlaylistBtn.addEventListener('click', saveEditedPlaylist);
            }
            if (cancelEditPlaylistBtn) {
                cancelEditPlaylistBtn.addEventListener('click', () => {
                    document.getElementById('editPlaylistModal').style.display = 'none';
                });
            }

            const addVideoSearchInput = document.getElementById('addVideoSearch');
            const confirmAddVideosBtn = document.getElementById('confirmAddVideos');
            const cancelAddVideosBtn = document.getElementById('cancelAddVideos');
            if (addVideoSearchInput) {
                addVideoSearchInput.addEventListener('input', searchAddVideos);
            }
            if (confirmAddVideosBtn) {
                confirmAddVideosBtn.addEventListener('click', addSelectedVideosToPlaylist);
            }
            if (cancelAddVideosBtn) {
                cancelAddVideosBtn.addEventListener('click', () => {
                    document.getElementById('addVideosModal').style.display = 'none';
                });
            }

            const selectAllAddVideosBtn = document.getElementById('selectAllAddVideos');
            if (selectAllAddVideosBtn) {
                selectAllAddVideosBtn.addEventListener('click', () => {
                    const searchTerm = document.getElementById('addVideoSearch').value.toLowerCase();
                    const existingNames = new Set((currentEditingPlaylist.videos || []).map(v => v.name));
                    const availableVideos = channelVideos.filter(v => !existingNames.has(v.name));
                    let currentDisplayedVideos = searchTerm ?
                        availableVideos.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(searchTerm)) :
                        availableVideos;
                    currentDisplayedVideos = naturalSortByName(currentDisplayedVideos);

                    currentDisplayedVideos.forEach(video => {
                        editingSelectedVideos.add(video.name);
                    });
                    renderAddVideoList(currentDisplayedVideos);
                    updateAddSelectionCounter();
                });
            }

            const clearAddSelectionBtn = document.getElementById('clearAddSelection');
            if (clearAddSelectionBtn) {
                clearAddSelectionBtn.addEventListener('click', () => {
                    const searchTerm = document.getElementById('addVideoSearch').value.toLowerCase();
                    const existingNames = new Set((currentEditingPlaylist.videos || []).map(v => v.name));
                    const availableVideos = channelVideos.filter(v => !existingNames.has(v.name));
                    let currentDisplayedVideos = searchTerm ?
                        availableVideos.filter(v => getFileNameWithoutExtension(v.name).toLowerCase().includes(searchTerm)) :
                        availableVideos;
                    currentDisplayedVideos = naturalSortByName(currentDisplayedVideos);

                    currentDisplayedVideos.forEach(video => {
                        editingSelectedVideos.delete(video.name);
                    });
                    renderAddVideoList(currentDisplayedVideos);
                    updateAddSelectionCounter();
                });
            }

            document.querySelectorAll('.close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const t = e.currentTarget.getAttribute('data-close');
                    if (t === 'create') document.getElementById('createPlaylistModal').style.display = 'none';
                    if (t === 'edit') document.getElementById('editPlaylistModal').style.display = 'none';
                    if (t === 'addVideos') document.getElementById('addVideosModal').style.display = 'none';
                    if (t === 'birthday') document.getElementById('birthdayModal').style.display = 'none';
                });
            });

            const avatarBtn = document.getElementById('avatarBtn');
            const avatarInput = document.getElementById('avatarInput');
            if (avatarBtn && avatarInput) {
                avatarBtn.replaceWith(avatarBtn.cloneNode(true));
                avatarInput.replaceWith(avatarInput.cloneNode(true));

                const newAvatarBtn = document.getElementById('avatarBtn');
                const newAvatarInput = document.getElementById('avatarInput');

                newAvatarBtn.addEventListener('click', () => {
                    newAvatarInput.click();
                });
                newAvatarInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        handleImageUpload(e.target.files[0], 'avatar');
                    }
                });
            }

            const headerBtn = document.getElementById('headerBtn');
            const headerInput = document.getElementById('headerInput');
            if (headerBtn && headerInput) {
                headerBtn.replaceWith(headerBtn.cloneNode(true));
                headerInput.replaceWith(headerInput.cloneNode(true));
                
                const newHeaderBtn = document.getElementById('headerBtn');
                const newHeaderInput = document.getElementById('headerInput');
                
                newHeaderBtn.addEventListener('click', () => {
                    newHeaderInput.click();
                });
                newHeaderInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        handleImageUpload(e.target.files[0], 'header');
                    }
                });
            }

            const bgBtn = document.getElementById('bgBtn');
            const bgInput = document.getElementById('bgInput');
            if (bgBtn && bgInput) {
                bgBtn.replaceWith(bgBtn.cloneNode(true));
                bgInput.replaceWith(bgInput.cloneNode(true));
                
                const newBgBtn = document.getElementById('bgBtn');
                const newBgInput = document.getElementById('bgInput');
                
                newBgBtn.addEventListener('click', () => {
                    newBgInput.click();
                });
                newBgInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        handleImageUpload(e.target.files[0], 'background');
                    }
                });
            }

            const colorBtn = document.getElementById('colorBtn');
            if (colorBtn) {
                colorBtn.replaceWith(colorBtn.cloneNode(true));
                const newColorBtn = document.getElementById('colorBtn');
                
                newColorBtn.addEventListener('click', () => {
                    channelData.textColor = channelData.textColor === 'white' ? 'black' : 'white';
                    saveChannelData();
                    renderChannel();
                });
            }

            const birthdayBtn = document.getElementById('birthdayBtn');
            if (birthdayBtn) {
                birthdayBtn.replaceWith(birthdayBtn.cloneNode(true));
                const newBirthdayBtn = document.getElementById('birthdayBtn');
                
                newBirthdayBtn.addEventListener('click', async () => {
                    const modal = document.getElementById('birthdayModal');
                    const daySelect = document.getElementById('birthdayDay');
                    const monthSelect = document.getElementById('birthdayMonth');
                    const yearInput = document.getElementById('birthdayYear');
                    
                    const getDaysInMonth = (month, year) => {
                        if (!month) return 31;
                        month = parseInt(month);
                        year = year ? parseInt(year) : new Date().getFullYear();
                        
                        const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                        
                        if (month === 2) {
                            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
                            return isLeapYear ? 29 : 28;
                        }
                        
                        return daysInMonth[month - 1];
                    };
                    
                    const updateDayOptions = () => {
                        const month = monthSelect.value;
                        const year = yearInput.value;
                        const currentDay = daySelect.value;
                        const maxDays = getDaysInMonth(month, year);
                        
                        const selectDayText = typeof i18n !== 'undefined' ? i18n.t('channelView.selectDay') : 'Выберите день';
                        daySelect.innerHTML = `<option value="">${selectDayText}</option>`;
                        for (let i = 1; i <= maxDays; i++) {
                            daySelect.innerHTML += `<option value="${i}">${i}</option>`;
                        }
                        
                        if (currentDay && parseInt(currentDay) <= maxDays) {
                            daySelect.value = currentDay;
                        }
                    };
                    
                    updateDayOptions();
                    
                    monthSelect.addEventListener('change', updateDayOptions);
                    yearInput.addEventListener('input', updateDayOptions);
                    
                    const birthdayData = await loadBirthdayData();
                    if (birthdayData) {
                        monthSelect.value = birthdayData.month || '';
                        yearInput.value = birthdayData.year || '';
                        updateDayOptions();
                        daySelect.value = birthdayData.day || '';
                    } else {
                        daySelect.value = '';
                        monthSelect.value = '';
                        yearInput.value = '';
                    }
                    
                    modal.style.display = 'block';
                });
            }

            const saveBirthdayBtn = document.getElementById('saveBirthday');
            const cancelBirthdayBtn = document.getElementById('cancelBirthday');
            const clearBirthdayBtn = document.getElementById('clearBirthday');
            const birthdayModal = document.getElementById('birthdayModal');
            
            if (saveBirthdayBtn) {
                saveBirthdayBtn.replaceWith(saveBirthdayBtn.cloneNode(true));
                const newSaveBirthdayBtn = document.getElementById('saveBirthday');
                
                newSaveBirthdayBtn.addEventListener('click', async () => {
                    const day = document.getElementById('birthdayDay').value;
                    const month = document.getElementById('birthdayMonth').value;
                    const year = document.getElementById('birthdayYear').value;
                    
                    if (!day || !month) {
                        const alertMsg = typeof i18n !== 'undefined' ? i18n.t('channelView.selectDayAndMonth') : 'Пожалуйста, выберите день и месяц';
                        alert(alertMsg);
                        return;
                    }
                    
                    const dayNum = parseInt(day);
                    const monthNum = parseInt(month);
                    const yearNum = year ? parseInt(year) : new Date().getFullYear();
                    
                    const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                    if (monthNum === 2) {
                        const isLeapYear = (yearNum % 4 === 0 && yearNum % 100 !== 0) || (yearNum % 400 === 0);
                        daysInMonth[1] = isLeapYear ? 29 : 28;
                    }
                    
                    if (dayNum > daysInMonth[monthNum - 1]) {
                        const alertMsg = typeof i18n !== 'undefined' 
                            ? i18n.t('channelView.monthHasOnlyDays', { days: daysInMonth[monthNum - 1] }) 
                            : `В выбранном месяце только ${daysInMonth[monthNum - 1]} дней`;
                        alert(alertMsg);
                        return;
                    }
                    
                    if (year) {
                        const currentYear = new Date().getFullYear();
                        if (yearNum < 1900 || yearNum > currentYear) {
                            const alertMsg = typeof i18n !== 'undefined' 
                                ? i18n.t('channelView.yearMustBeBetween', { min: 1900, max: currentYear }) 
                                : `Год должен быть между 1900 и ${currentYear}`;
                            alert(alertMsg);
                            return;
                        }
                    }
                    
                    const birthdayData = {
                        channelName: currentChannelName,
                        day: dayNum,
                        month: monthNum,
                        year: year ? yearNum : null
                    };
                    
                    await saveBirthdayData(birthdayData);
                    birthdayModal.style.display = 'none';
                    
                    const videoCount = channelVideos.length;
                    const totalViews = channelVideos.reduce((sum, v) => sum + (v.views || 0), 0);
                    await updateChannelStats(videoCount, totalViews);
                });
            }
            
            if (cancelBirthdayBtn) {
                cancelBirthdayBtn.replaceWith(cancelBirthdayBtn.cloneNode(true));
                const newCancelBirthdayBtn = document.getElementById('cancelBirthday');
                
                newCancelBirthdayBtn.addEventListener('click', () => {
                    birthdayModal.style.display = 'none';
                });
            }
            
            if (clearBirthdayBtn) {
                clearBirthdayBtn.replaceWith(clearBirthdayBtn.cloneNode(true));
                const newClearBirthdayBtn = document.getElementById('clearBirthday');
                
                newClearBirthdayBtn.addEventListener('click', async () => {
                    const confirmMsg = typeof i18n !== 'undefined' ? i18n.t('channelView.confirmDeleteBirthday') : 'Вы уверены, что хотите удалить дату рождения?';
                    if (confirm(confirmMsg)) {
                        await deleteBirthdayData();
                        birthdayModal.style.display = 'none';
                        
                        const videoCount = channelVideos.length;
                        const totalViews = channelVideos.reduce((sum, v) => sum + (v.views || 0), 0);
                        await updateChannelStats(videoCount, totalViews);
                    }
                });
            }

            const searchInput = document.getElementById('headerSearchInput');
            const searchBtn = document.getElementById('headerSearchBtn');
            
            if (searchInput) {
                searchInput.replaceWith(searchInput.cloneNode(true));
                const newSearchInput = document.getElementById('headerSearchInput');
                newSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const q = (newSearchInput.value||'').trim();
                        const params = new URLSearchParams();
                        if (q) params.set('q', q);
                        params.set('type','channels');
                        window.location.href = `youvi_search.html?${params.toString()}`;
                    }
                });
            }
            if (searchBtn) {
                searchBtn.replaceWith(searchBtn.cloneNode(true));
                const newSearchBtn = document.getElementById('headerSearchBtn');
                newSearchBtn.addEventListener('click', (e)=>{
                    e.preventDefault();
                    const q = (document.getElementById('headerSearchInput')?.value||'').trim();
                    const params = new URLSearchParams();
                    if (q) params.set('q', q);
                    params.set('type','channels');
                    window.location.href = `youvi_search.html?${params.toString()}`;
                });
            }
        });

        function searchByTag(tag) {
            console.log('Searching by tag:', tag);
        }




        window.addEventListener('subscriptionChanged', async function() {
            await setupSubscriptionButton();
        });

        window.addEventListener('storage', async function(e) {
            if (e.key === '8site_subscriptions') {
                await setupSubscriptionButton();
            }
        });



        window.pinVideo = pinVideo;
        window.unpinVideo = unpinVideo;
        window.playPinnedVideo = playPinnedVideo;


        async function setupSubscriptionButton() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (!subscribeBtn || !currentChannelName) return;

            try {
                let subscriptions = await loadSubscriptionsFromFile();
                let db = null;
                
                if (!subscriptions) {
                    db = await openDB();
                    subscriptions = await getFromDB(db, 'subscriptions') || [];
                }
                
                if (!Array.isArray(subscriptions)) {
                    subscriptions = [];
                }
                
                const isSubscribed = subscriptions.includes(currentChannelName);
                if (CHANNEL_VIEW_DEBUG) console.log('Current channel:', currentChannelName, 'Is subscribed:', isSubscribed);

                const subscribeText = typeof i18n !== 'undefined' ? i18n.t('channelView.subscribe') : 'Подписаться';
                const unsubscribeText = typeof i18n !== 'undefined' ? i18n.t('channelView.unsubscribe') : 'Отписаться';
                
                if (isSubscribed) {
                    subscribeBtn.textContent = unsubscribeText;
                    subscribeBtn.classList.add('subscribed');
                } else {
                    subscribeBtn.textContent = subscribeText;
                    subscribeBtn.classList.remove('subscribed');
                }

                let currentSubscriptionState = isSubscribed;

                subscribeBtn.addEventListener('click', async () => {
                    try {
                        if (CHANNEL_VIEW_DEBUG) console.log('Subscription button clicked. Current state:', currentSubscriptionState);
                        
                        if (!db) {
                            if (CHANNEL_VIEW_DEBUG) console.log('Creating new database connection...');
                            db = await openDB();
                        }
                        
                        if (!subscriptions || !Array.isArray(subscriptions)) {
                            subscriptions = await loadSubscriptionsFromFile() || [];
                            if (!Array.isArray(subscriptions)) {
                                subscriptions = [];
                            }
                        }
                        
                        const subscribeLabel = typeof i18n !== 'undefined' ? i18n.t('channelView.subscribe') : 'Подписаться';
                        const unsubscribeLabel = typeof i18n !== 'undefined' ? i18n.t('channelView.unsubscribe') : 'Отписаться';
                        
                        if (currentSubscriptionState) {
                            if (CHANNEL_VIEW_DEBUG) console.log('Unsubscribing from channel:', currentChannelName);
                            const index = subscriptions.indexOf(currentChannelName);
                            if (index > -1) {
                                subscriptions.splice(index, 1);
                                if (CHANNEL_VIEW_DEBUG) console.log('Updated subscriptions list after unsubscribe:', subscriptions);
                                
                                await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);
                                
                                subscribeBtn.textContent = subscribeLabel;
                                subscribeBtn.classList.remove('subscribed');
                                currentSubscriptionState = false;
                                
                                const verification = localStorage.getItem('8site_subscriptions');
                                if (CHANNEL_VIEW_DEBUG) console.log('Verification - localStorage after unsubscribe:', verification);
                                await renderSubscribedChannelsList();
                            }
                        } else {
                            if (CHANNEL_VIEW_DEBUG) console.log('Subscribing to channel:', currentChannelName);
                            if (!subscriptions.includes(currentChannelName)) {
                                subscriptions.push(currentChannelName);
                            }
                            if (CHANNEL_VIEW_DEBUG) console.log('Updated subscriptions list after subscribe:', subscriptions);

                            await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);

                            subscribeBtn.textContent = unsubscribeLabel;
                            subscribeBtn.classList.add('subscribed');
                            currentSubscriptionState = true;

                            const verification = localStorage.getItem('8site_subscriptions');
                            if (CHANNEL_VIEW_DEBUG) console.log('Verification - localStorage after subscribe:', verification);
                            await renderSubscribedChannelsList();
                        }
                    } catch (e) {
                        if (CHANNEL_VIEW_DEBUG) console.error('Error updating subscription:', e);
                    }
                });
            } catch (e) {
                if (CHANNEL_VIEW_DEBUG) console.error('Error setting up subscription button:', e);
                subscribeBtn.textContent = typeof i18n !== 'undefined' ? i18n.t('channelView.subscribe') : 'Подписаться';
                subscribeBtn.classList.remove('subscribed');
            }
        }

        function setupQMSButton() {
            const qmsBtn = document.getElementById('qmsBtn');
            if (!qmsBtn || !currentChannelName) return;

            qmsBtn.addEventListener('click', () => {
                let currentUser = localStorage.getItem('forumNick') || 
                                localStorage.getItem('youviNick') || 
                                localStorage.getItem('8site_username');
                
                if (!currentUser) {
                    currentUser = prompt('Введите ваш ник для отправки сообщения:');
                    if (!currentUser) return;
                    
                    localStorage.setItem('youviNick', currentUser);
                    localStorage.setItem('forumNick', currentUser);
                }

                const messagesUrl = `messages.html?peer=${encodeURIComponent(currentChannelName)}`;
                window.location.href = messagesUrl;
            });
        }

        function setupForumButton() {
            const forumBtn = document.getElementById('forumBtn');
            if (!forumBtn || !currentChannelName) return;

            forumBtn.addEventListener('click', async () => {
                try {
                    await createForumProfileFromYouvi(currentChannelName);
                    
                    const profileUrl = `forum_profile.html?nick=${encodeURIComponent(currentChannelName)}`;
                    window.open(profileUrl, '_blank');
                } catch (error) {
                    console.error('Error opening forum profile:', error);
                    const profileUrl = `forum_profile.html?nick=${encodeURIComponent(currentChannelName)}`;
                    window.open(profileUrl, '_blank');
                }
            });
        }

        async function createForumProfileFromYouvi(channelName) {
            try {
                const db = await openDB();
                const forumDirectoryHandle = await getFromDB(db, 'forumDirectoryHandle');
                if (!forumDirectoryHandle) return false;

                const usersDir = await forumDirectoryHandle.getDirectoryHandle('users', {create: true});
                const slugName = channelName.toLowerCase().trim()
                    .replace(/\s+/g, '_')
                    .replace(/[^a-z0-9_\-.а-я]/gi, '');
                
                try {
                    await usersDir.getDirectoryHandle(slugName, {create: false});
                    return true;
                } catch {
                }

                if (!videoDirectoryHandle) return false;
                
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', {create: true});
                const channelDir = await channelsDir.getDirectoryHandle(slugName, {create: false});
                const channelData = await readJSONFile(channelDir, 'channel.json') || {};
                
                const userDir = await usersDir.getDirectoryHandle(slugName, {create: true});
                
                const profileData = {
                    nick: channelName,
                    about: channelData.description || `Владелец канала ${channelName}`,
                    created: Date.now(),
                    autoCreated: true,
                    fromYouvi: true
                };
                
                await writeJSONFile(userDir, 'profile.json', profileData);
                
                await writeJSONFile(userDir, 'profile.json', profileData);
                
                console.log(`Auto-created forum profile for ${channelName}`);
                return true;
            } catch (e) {
                console.error('Error creating forum profile:', e);
                return false;
            }
        }



























        document.addEventListener('DOMContentLoaded', () => {
            const editDescriptionBtn = document.getElementById('editDescriptionBtn');
            const saveDescriptionBtn = document.getElementById('saveDescriptionBtn');
            const cancelDescriptionBtn = document.getElementById('cancelDescriptionBtn');
            const descriptionView = document.getElementById('descriptionView');
            const descriptionEdit = document.getElementById('descriptionEdit');
            const descriptionTitle = document.getElementById('descriptionTitle');
            const descriptionEditor = document.getElementById('descriptionEditor');
            const descriptionToolbar = document.getElementById('descriptionToolbar');

            if (editDescriptionBtn) {
                editDescriptionBtn.addEventListener('click', () => {
                    descriptionView.style.display = 'none';
                    descriptionEdit.style.display = 'block';
                    
                    descriptionTitle.value = channelData.descriptionTitle || '';
                    descriptionEditor.innerHTML = channelData.description || '<p><br></p>';
                    
                    descriptionEditor.focus();
                });
            }

            if (saveDescriptionBtn) {
                saveDescriptionBtn.addEventListener('click', async () => {
                    const title = descriptionTitle.value.trim();
                    const content = descriptionEditor.innerHTML.trim();
                    
                    if (!content || content === '<p><br></p>') {
                        alert('Введите описание канала');
                        return;
                    }
                    
                    channelData.descriptionTitle = title;
                    channelData.description = content;
                    await saveChannelData();
                    
                    await loadDescriptionAndTags();
                    descriptionView.style.display = 'block';
                    descriptionEdit.style.display = 'none';
                    
                    alert('Описание сохранено');
                });
            }

            if (cancelDescriptionBtn) {
                cancelDescriptionBtn.addEventListener('click', () => {
                    descriptionView.style.display = 'block';
                    descriptionEdit.style.display = 'none';
                });
            }

            if (descriptionToolbar) {
                descriptionToolbar.addEventListener('click', (ev) => {
                    const btn = ev.target.closest('button');
                    if (!btn) return;
                    
                    const cmd = btn.dataset.cmd;
                    const editor = document.getElementById('descriptionEditor');
                    
                    if (!editor) return;
                    
                    editor.focus();
                    
                    if (['bold', 'italic', 'underline'].includes(cmd)) {
                        document.execCommand(cmd, false, null);
                        btn.classList.toggle('active');
                        return;
                    }
                    
                    if (cmd === 'insertUnorderedList' || cmd === 'insertOrderedList') {
                        document.execCommand(cmd, false, null);
                        return;
                    }
                    
                    if (cmd === 'formatBlock') {
                        document.execCommand(cmd, false, btn.dataset.value);
                        return;
                    }
                });
            }

            const createLinkBtn = document.getElementById('createLinkBtn');
            if (createLinkBtn) {
                createLinkBtn.addEventListener('click', () => {
                    const url = prompt('Вставьте URL');
                    if (url) {
                        const editor = document.getElementById('descriptionEditor');
                        if (editor) {
                            editor.focus();
                            const selection = document.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                const link = document.createElement('a');
                                link.href = url;
                                link.textContent = selection.toString() || url;
                                range.deleteContents();
                                range.insertNode(link);
                            }
                        }
                    }
                });
            }
            
            if (descriptionEditor) {
                descriptionEditor.addEventListener('mouseup', updateButtonStates);
                descriptionEditor.addEventListener('keyup', updateButtonStates);
                descriptionEditor.addEventListener('input', updateButtonStates);
                
                descriptionEditor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const selection = document.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            const listItem = range.commonAncestorContainer.closest('li');
                            
                            if (listItem) {
                                const list = listItem.closest('ul, ol');
                                if (list) {
                                    if (listItem.textContent.trim() === '') {
                                        e.preventDefault();
                                        listItem.remove();
                                        if (list.children.length === 0) {
                                            list.remove();
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (e.key === 'Backspace') {
                        const selection = document.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            const listItem = range.commonAncestorContainer.closest('li');
                            
                            if (listItem) {
                                const list = listItem.closest('ul, ol');
                                if (list && range.startOffset === 0 && listItem.textContent.trim() === '') {
                                    e.preventDefault();
                                    listItem.remove();
                                    if (list.children.length === 0) {
                                        list.remove();
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            function updateButtonStates() {
                const boldBtn = descriptionToolbar.querySelector('[data-cmd="bold"]');
                const italicBtn = descriptionToolbar.querySelector('[data-cmd="italic"]');
                const underlineBtn = descriptionToolbar.querySelector('[data-cmd="underline"]');
                
                boldBtn.classList.toggle('active', document.queryCommandState('bold'));
                italicBtn.classList.toggle('active', document.queryCommandState('italic'));
                underlineBtn.classList.toggle('active', document.queryCommandState('underline'));
            }
            








            const allVideosBtn = document.getElementById('allVideosBtn');
            const allPlaylistsBtn = document.getElementById('allPlaylistsBtn');

            if (allVideosBtn) {
                allVideosBtn.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('[data-tab="videos"]').classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    document.getElementById('videosTab').classList.add('active');
                    
                    const sortingSection = document.getElementById('sortingSection');
                    if (sortingSection) {
                        sortingSection.style.display = 'block';
                    }
                });
            }

            if (allPlaylistsBtn) {
                allPlaylistsBtn.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('[data-tab="playlists"]').classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    document.getElementById('playlistsTab').classList.add('active');
                    
                    const sortingSection = document.getElementById('sortingSection');
                    if (sortingSection) {
                        sortingSection.style.display = 'block';
                    }
                });
            }

            

        





        });












        async function toggleVideoPin(video) {
            if (channelData.pinnedVideo === video.name) {
                channelData.pinnedVideo = null;
            } else {
                channelData.pinnedVideo = video.name;
            }
            
            await saveChannelData();
            
            await loadPinnedVideo();
            
            const pinElement = document.querySelector(`[data-video-name="${video.name}"]`)?.querySelector('.video-pin-hover');
            if (pinElement) {
                const isPinned = channelData.pinnedVideo === video.name;
                pinElement.title = isPinned ? 'Открепить видео' : 'Закрепить видео';
                pinElement.style.background = isPinned ? 'rgba(255,105,180,0.8)' : 'rgba(0,0,0,0.7)';
                pinElement.setAttribute('data-pinned', isPinned);
                pinElement.style.opacity = isPinned ? '1' : '0';
            }
            
        }

    </script>

    <style>
        .playlist-item {
            position: relative;
            background: transparent; 
            border: none;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            margin-bottom: 8px;
            transition: background-color 0.15s, border-color 0.15s;
        }
        
        .playlist-item:hover {
            background: transparent; 
            border-color: #ddd;
            transform: none;
            box-shadow: none;
        }

        .playlist-thumbnail {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            aspect-ratio: 16/9;
            background: #f0f0f0;
            position: relative;
        }

        .playlist-thumb {
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 10px;
            border: none;
            position: relative;
            overflow: hidden;
        }
        
        .playlist-info {
            background: transparent; 
            border: none;
            padding: 12px;
        }

        .playlist-title {
            color: #333;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .playlist-meta {
            color: #666;
            font-size: 12px;
        }
        
        .skeleton-item {
            pointer-events: none;
        }
        
        .skeleton-thumb {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
            aspect-ratio: 16/9;
            border-radius: 6px;
        }
        
        .skeleton-line {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
            border-radius: 4px;
        }
        
        @keyframes skeleton-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        body.dark-theme .skeleton-thumb,
        body.dark-theme .skeleton-line {
            background: linear-gradient(90deg, #3a3a3a 25%, #4a4a4a 50%, #3a3a3a 75%);
            background-size: 200% 100%;
        }
        
        .video-item {
            position: relative;
        }
        
        .video-thumb {
            position: relative;
        }
        
        .top-video-item {
            position: relative;
        }
        
        .top-video-thumb {
            position: relative;
        }
        
        .video-item-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            opacity: 0;
            pointer-events: none;
            text-decoration: none;
            color: transparent;
        }
        
        .video-item:hover .video-item-link {
            pointer-events: auto;
        }
        
        .top-video-item:hover .video-item-link {
            pointer-events: auto;
        }

        .playlist-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .playlist-count-badge {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 11px;
            font-family: Roboto, Arial, sans-serif;
        }

        .playlist-info {
            padding: 6px 8px;
            background: #fff;
            border-top: 1px solid #ddd;
        }
        
        body.dark-theme .playlist-info {
            background: #000;
            border-top-color: #333;
        }

        .playlist-channel {
            font-size: 11px;
            color: #ff69b4;
            font-family: Verdana, Arial, sans-serif;
        }
        
        body.dark-theme .sidebar-item {
            color: #ccc;
        }
        
        body.dark-theme .sidebar-item:hover {
            color: #ff69b4;
        }
        
        body.dark-theme .sidebar-item.active {
            color: #fff;
        }
        
        body.dark-theme #allTagsLink {
            color: #ccc;
        }
        
        body.dark-theme #allTagsLink:hover {
            color: #ff69b4;
        }
        
        body.dark-theme #allTagsLink.active {
            color: #fff;
        }

        .playlist-title {
            font-weight: 500;
            font-size: 14px;
            color: #000;
            margin: 2px 0;
            font-family: Verdana, Arial, sans-serif;
        }

        .playlist-open {
            font-size: 12px;
            color: #666;
        }

        .playlist-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .playlist-item:hover .playlist-actions {
            opacity: 1;
        }

        .playlist-edit-btn:hover,
        .playlist-delete-btn:hover {
            background: rgba(217, 75, 136, 0.9) !important;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10001;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #fff;
            border-radius: 8px;
            max-width: 700px;
            width: 90%;
            margin: 50px auto;
            padding: 20px;
            max-height: 85vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-actions {
            display: flex;
            gap: 6px;
            margin: 8px 0;
            justify-content: flex-end;
        }

        .video-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            flex: 1;
            min-height: 200px;
        }

        .video-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .video-list-item:hover {
            background: #f9f9f9;
        }

        .video-list-item:last-child {
            border-bottom: none;
        }

        .video-list-item input[type="checkbox"] {
            margin: 0;
        }

        .video-list-item label {
            flex: 1;
            font-size: 13px;
            cursor: pointer;
            margin: 0;
        }

        .video-list-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .video-list-item.drag-over {
            border-top: 3px solid #d94b88;
        }

        .drag-handle {
            cursor: move;
            color: #666;
            font-size: 14px;
            padding: 0 4px;
            margin-right: 4px;
        }

        .drag-handle:hover {
            color: #d94b88;
        }

        .empty-state {
            text-align: center;
            color: #7a3c55;
            padding: 60px 20px;
            font-size: 16px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .search-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            text-align: center;
        }

        .playlist-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .video-search {
            margin-bottom: 8px;
        }

        .video-search input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

                body.dark-theme input.search-input {
  background: #4a3a34 !important;
  color: #fff !important;
  border-color: #555 !important;
}
        .video-pin-hover {
            transition: all 0.2s ease !important;
            pointer-events: auto !important;
        }
        
        .video-pin-hover:hover {
            transform: scale(1.1) !important;
        }
        
        .video-pin-hover {
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .video-item:hover .video-pin-hover {
            opacity: 1;
        }
        
        .video-pin-hover:hover {
            background: #ff69b4 !important;
        }
        
        body.dark-theme .playlist-title {
            color: #fff;
        }
        
        body.dark-theme .playlist-meta {
            color: #aaa;
        }
        
        body.dark-theme .playlist-channel {
            color: #ff69b4;
        }
        
        body.custom-background #pinnedVideo,
        body.custom-background #descriptionView,
        body.custom-background #descriptionEdit,
        body.custom-background .modal-content {
            background: rgba(255, 255, 255, 0.85) !important;
            backdrop-filter: blur(10px);
        }
        
        body.custom-background .tab-content div[style*="background:#fff"]:not(.modal-content):not(#pinnedVideo):not(#descriptionView):not(#descriptionEdit) {
            background: rgba(255, 255, 255, 0.85) !important;
            backdrop-filter: blur(10px);
        }
        
        body.custom-background.dark-theme #pinnedVideo,
        body.custom-background.dark-theme #descriptionView,
        body.custom-background.dark-theme #descriptionEdit,
        body.custom-background.dark-theme .modal-content {
            background: rgba(30, 30, 30, 0.85) !important;
            backdrop-filter: blur(10px);
        }
        
        body.custom-background.dark-theme .tab-content div[style*="background:#fff"]:not(.modal-content):not(#pinnedVideo):not(#descriptionView):not(#descriptionEdit) {
            background: rgba(30, 30, 30, 0.85) !important;
            backdrop-filter: blur(10px);
        }
    </style>
    
    <script src="youvi/themes/theme-toggle.js"></script>
    
    <!-- Language Switcher Initialization -->
    <script>
        function updateBirthdayModalMonths() {
            if (typeof i18n === 'undefined') return;
            
            const monthSelect = document.getElementById('birthdayMonth');
            if (!monthSelect) return;
            
            const monthNames = i18n.t('channelView.monthNames');
            if (!Array.isArray(monthNames)) return;
            
            const options = monthSelect.querySelectorAll('option[data-i18n-month]');
            options.forEach(option => {
                const monthIndex = parseInt(option.getAttribute('data-i18n-month'));
                if (monthNames[monthIndex]) {
                    option.textContent = monthNames[monthIndex];
                }
            });
            
            const selectMonthOption = monthSelect.querySelector('option[data-i18n="channelView.selectMonth"]');
            if (selectMonthOption) {
                selectMonthOption.textContent = i18n.t('channelView.selectMonth');
            }
            
            const daySelect = document.getElementById('birthdayDay');
            if (daySelect) {
                const selectDayOption = daySelect.querySelector('option[data-i18n="channelView.selectDay"]');
                if (selectDayOption) {
                    selectDayOption.textContent = i18n.t('channelView.selectDay');
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const langSwitcher = document.getElementById('langSwitcher');
            if (langSwitcher && typeof i18n !== 'undefined') {
                langSwitcher.value = i18n.getCurrentLanguage();
                
                langSwitcher.addEventListener('change', function() {
                    i18n.setLanguage(this.value);
                });
                
                i18n.subscribe(function(lang) {
                    langSwitcher.value = lang;
                    updateBirthdayModalMonths();
                    if (typeof channelAchievementsInstance !== 'undefined' && channelAchievementsInstance) {
                        channelAchievementsInstance.renderAchievements();
                    }
                    if (typeof channelVideos !== 'undefined' && channelVideos.length > 0) {
                        const totalViews = channelVideos.reduce((sum, v) => sum + (v.views || 0), 0);
                        updateChannelStats(channelVideos.length, totalViews);
                    }
                });
                
                updateBirthdayModalMonths();
            }
        });
    </script>
</body>
</html>